# 设计模式

**一、单例模式（创建型模式）**

单例类只能有一个实例；单例类必须自己创建自己的唯一实例；单例类必须给所有其他对象提供这一实例

* 目的：保证一个类仅有一个实例，并提供一个访问它的全局访问点
* 主要解决：一个全局使用的类频繁地创建与销毁问题
* 优点：内存中只有一个实例，节省系统资源，尤其是频繁创建和销毁实例；避免对资源的多重占用
* 缺点：没有接口，不能继承，与类的单一职责原则冲突（一个类只应该关心内部逻辑而不关心外部如何实例化）

**二、观察者模式（行为型模式）**

对象间存在一对多关系

* 目的：当一个对象被修改时，则会自动通知它的依赖对象
* 主要解决：一个对象状态改变给其他对象通知的问题，且要考虑易用和低耦合，保证高度的协作
* 优点：观察者和被观察者是依赖的（紧耦合）
* 缺点：观察者仅能知道目标对象发生了变化，而不知道是怎么发生变化的；如果观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能会导致系统崩溃；被观察对象如果有很多直接或间接的观察者的话，将所有观察者都通知到会花费很多时间

**三、发布-订阅模式（广义上的观察者模式）**

发布者和订阅者不知道对方的存在，需要一个第三方组件，即信息中介将订阅者和发布者串联起来，它过滤和分配所有输入的消息

**四、发布-订阅模式与观察者模式的区别**

1. 观察者模式中，observer知道subject的存在，subject一直保持对观察者进行记录；发布-订阅模式中，publisher和subscriber不知道对方的存在，它们只有通过消息代理进行通信
2. 观察者模式中，组件是紧耦合的；发布订阅模式中，组件是松散耦合的
3. 观察者模式大多数时候是同步的，比如当事件触发，subject就会去调用观察者的方法；发布-订阅模式大多数时候是异步的（使用消息队列）

![](<../../.gitbook/assets/设计模式 (2).jpg>)
