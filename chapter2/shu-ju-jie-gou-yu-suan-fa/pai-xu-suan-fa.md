# 排序算法

#### 先来看下常见排序算法的分类：

![](<../../.gitbook/assets/排序算法分类 (1).jpg>)

* **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
* **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。

**1、冒泡排序（Bubble Sort）**\
冒泡排序是一种简单的排序算法，通过一趟又一趟地比较数组中的每一个元素，使较大的数据下沉，较小的数据上升。

**2、选择排序（Selection Sort）**\
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

**3、插入排序（Insertion Sort）**\
通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

**4、希尔排序（Shell Sort）**\
希尔排序是简单插入排序的改进版，通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。

**5、归并排序（Merge Sort）**\
归并排序的核心思想是分而治之（Divide and Conquer）：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

**6、快速排序（Quick Sort）**\
通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

**7、堆排序（Heap Sort）**\
堆排序是指利用堆这种数据结构所设计的一种排序算法。堆排序会将所有的数据建成一个堆，最大的数据在堆顶，然后将堆顶数据和序列的最后一个数据交换。接下来再次重建堆，交换数据，依次下去，就可以排序所有的数据。

**8、计数排序（Counting Sort）**\
计数排序核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

**9、桶排序（Bucket Sort）**\
桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。

**10、基数排序（Radix Sort）**\
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。



#### 最后，附上**算法复杂度比较表**：

![](<../../.gitbook/assets/排序算法比较 (1).jpg>)

* **稳定**：a原本在b前面且a=b，排序之后a仍然在b的前面。
* **不稳定**：a原本在b的前面且a=b，排序之后 a 可能会出现在 b 的后面。

注：n小时，冒泡排序、交换排序、选择排序比较适用；n大时，快速排序、归并排序、堆排序比较适用；对于大部分已排序好的数列，插入排序比较适用。

参考：[十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html) [排序算法比较·面试宝典](https://troywu0.gitbooks.io/spark/content/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.html)
