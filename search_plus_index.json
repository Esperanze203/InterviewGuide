{"./":{"url":"./","title":"前言","keywords":"","body":"前言 二月中春节过后没事情干，每天LeetCode刷刷算法题玩。没想到一个月后得靠它找工作。三月底才开始投简历准备春招，说实话时间挺赶的，一个多月能拿到offer真的非常惊喜了。我的准备就是分为算法+技术问题，笔试前主攻算法，收到面试通知后转向技术问题。算法主要刷的LeetCode，技术问题看的是牛客网的面经汇总，以及各大论坛网站搜罗近期面试过的同学们的回忆录。 这本前端面试小本本的大部分题目是整理自牛客网的【前端工程师面试宝典】，原文重复的地方比较多，看的时候做了些归纳和整理，方便查阅；同时把自己搜罗的题目、面试时候遇到的问题也加了进去。有的知识点可能需要深入理解原理，不是三言两语就能概括讲清楚的，我在参考里附上了我觉得讲的很好的博客地址，希望大家可以点开原文看一下加深印象。 前端的知识点真的是细碎繁多，希望这本书能帮助大家节省搜集资料的时间、高效准备。以我自己的经历来看，这些内容可以涵盖面试中80%的知识点了。 最后祝愿大家都能拿到自己心仪的offer！ powered by Gitbook最后修订时间： 2020-05-15 09:50:35 "},"Chapter1/":{"url":"Chapter1/","title":"自我介绍一下","keywords":"","body":"自我介绍一下 这是面试官100%会问的问题，如果你只是用一分钟来重复你的简历，那么，你的印象加分没有了！ 避免查户口式的平常回答，不妨坦诚自信地展现自我：姓名、学校、专业等基本信息一句话带过，重点突出与应聘职位相吻合的优势，比如大学期间重点学习研究的方向、做过哪些类型的项目、在项目中主要担任的角色等等。 你的相关能力和素质是企业最感兴趣的信息。因为，多数情况下，在听取你的介绍时，面试官也会抓住他感兴趣的点深入询问。所以，在进行表述时，要力求以真实为基础，顾及表达的逻辑性和条理性，避免冗长而没有重点的叙述。一定要在最短的时间内激发起面试官对你的好感。 自我介绍结束后，面试官一般会根据你的自我介绍和简历，紧接着就询问你做过的项目情况。有时候，为了显示自己的项目经历丰富，做简历的时候那些年代久远的项目也会被放进去，可是万一被问到忘记了答不上来岂不很尴尬？！毕竟技术这种东西时间长不用就记不清了。 这里有一个小技巧来引导面试官去询问你最熟悉的项目——在自我介绍的时候就告诉面试官“我最近在做的一个项目是......”或是“大学期间，让我收获最大的一个项目是......”，省略号处简单概括一下就行，不用展开说，具体内容在后续的项目介绍中再细说用到的技术等细节吧！ 对自己简历中提到的项目和相关技术一定要熟悉！因为这是之后技术面五成以上问题的“接口”。 powered by Gitbook最后修订时间： 2020-05-14 09:22:16 "},"Chapter2/":{"url":"Chapter2/","title":"计算机基础","keywords":"","body":"计算机基础 每个计算机专业的人都会学的课程：操作系统、数据库、计算机网络、数据结构和程序设计基础。 前端的话计算机网络肯定没跑，计算机网络协议和体系结构不用说也知道是大头了（关于HTTP/HTTPS的内容，东西太多，所以我和浏览器放在一起单列了一个章节），剩下的问的多一点的就是操作系统。数据库的话以我的经历，面试官会让你解释一些简单的SELECT语句，这个实在不知道怎么写，自己去看看了解一下吧，不作为重点。数据结构和程序设计主要体现在算法题中。 至于我为什么又放了一节JAVA的内容进来，等你翻到那一节就知道了:) powered by Gitbook最后修订时间： 2020-05-14 15:57:06 "},"Chapter2/操作系统.html":{"url":"Chapter2/操作系统.html","title":"操作系统","keywords":"","body":"操作系统 前端的面试操作系统部分主要是一些基础的概念性知识或是易混淆的点，Linux、文件系统什么的比较难的部分一般考不到。 本章主要介绍以下六个高频知识点： 并发与并行 进程的三种状态 进程调度 进程间通信方式 进程与线程 死锁 powered by Gitbook最后修订时间： 2020-05-14 14:13:11 "},"Chapter2/操作系统/进程的三种状态.html":{"url":"Chapter2/操作系统/进程的三种状态.html","title":"进程的三种状态","keywords":"","body":"进程的三种状态 就绪（Ready）状态 进程已分配到除CPU以外的所有必要资源，只要获得处理机便可立即执行。 执行（Running）状态 进程已获得处理机，其程序正在处理机上执行。 阻塞（Blocked）状态 正在执行的程序，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的原因可能是等待I/O完成、申请缓冲区不能满足、等待信号等。 Q1：为什么在转换图中没有就绪到阻塞和阻塞到执行的转换方向？ 就绪状态进程没有占有处理机，即不经过执行，其状态就不会改变；阻塞状态进程唤醒后要先进入到就绪队列，才会被调度程序选中，进行执行状态 powered by Gitbook最后修订时间： 2020-05-14 19:15:16 "},"Chapter2/操作系统/进程调度.html":{"url":"Chapter2/操作系统/进程调度.html","title":"进程调度","keywords":"","body":"进程调度 一、进程调度任务 保存处理机的现场信息，如程序计数器、多个通用寄存器中的内容等； 按照某种算法选取进程，将其状态改为运行状态； 把处理器分配给进程，将进程控制块内有关处理器现场。信息装入处理器相应的寄存器中，处理器的控制权交给该进程，让它从上次断点处恢复运行。 二、进程调度机制 排队器：将所有就绪的进程按照一定的策略排成一个或多个队列 分派器：取出进程调度程序选中的进程，进行进程间上下文切换、分配处理器 上下文切换器：将当前进程的上下文信息保存到相应单元，装入分派程序的上下文；移出分派程序的上下文，装入新选进程的现场信息 三、进程调度方式 非抢占式：一旦处理机分配给某个进程后，就一直让其运行直到完成或者发生某事件而阻塞。 抢占式：允许调度程序根据某种规则，暂停某个正在执行的进程。 四、进程调度算法 FCFS先来先服务算法（非抢占式）按照作业进入后备作业队列的先后次序来挑选作业 优点：实现简单 缺点：效率不高，性能不好；有利于长作业，不利于短作业 短作业优先算法（非抢占式）每次从后备作业队列中挑选估计服务时间最短的一个或几个作业 优点：优先照顾短作业，可以降低平均等待时间，提高吞吐量缺点：不利于长作业，长作业可能一直处于等待状态，容易出现饥饿现象；未考虑作业的优先紧迫程度，不能用于实时系统 HPF优先级调度算法（非抢占式）按照优先级由高到低的顺序进行调度 HRRF高响应比优先调度算法（非抢占式）：适用于批处理系统每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选响应比最高的作业。 优点：能够避免饥饿现象，兼顾长短作业缺点：计算响应比开销大 RR时间片轮转调度算法（抢占式）：适用于分时系统给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行。 切换时机：（1）时间片未用完，进程便完成；（2）时间片用完，终端处理程序被激活，进程若未完成被送入就绪队列尾部 优点：兼顾长短作业缺点：平均等待时间较长，上下文切换较费时 多级反馈队列调度算法（抢占式）：适用于各种作业环境设置多个就绪队列，每个队列赋予不同的优先级；每个队列采用FCFS算法，新进程进入时首先放入第一队列末尾，若第一个时间结束未完成，将其转入第二队列末尾……。队列按优先级调度，仅当前一队列空闲时才调用下一队列。 优点：兼顾长短作业，有较好的响应时间，可行性强 powered by Gitbook最后修订时间： 2020-05-14 11:52:39 "},"Chapter2/操作系统/死锁.html":{"url":"Chapter2/操作系统/死锁.html","title":"死锁","keywords":"","body":"死锁 一、死锁的定义 死锁是两个或两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象；若无外力干预，它们都将无法推进下去。（竞争的资源可以是锁、线程、网络连接、通知事件、打印机、磁盘、宽带等） 二、死锁产生的原因 系统资源不足；进程运行推进顺序不当；资源分配不当 三、死锁的四个必要条件 只要系统发生死锁，这些条件必然成立；只要条件之一不满足就不会发生死锁。 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：进程已获得的资源在未使用完之前不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系 四、解决死锁的方法 三种方法：死锁的预防、死锁的避免、死锁的检查与恢复 死锁的预防（静态策略） 基本思想：要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。 (1) 打破请求与保持条件 预先分配资源，即进程在运行前一次性地向系统申请它所需要的的全部资源。若某个进程所需的全部资源得不到满足则不分配任何资源，此进程暂不运行，直到系统能够满足当前进程的全部资源时才一次性将所申请的资源全部分配给该进程。 缺点：进程的执行过程是动态的、不可预测的，许多情况下一个进程在执行之前不可能知道它所需的全部资源；资源利用率低；降低进程的并发性。 (2) 打破循环等待条件 实行资源有序分配策略，即事先将资源分类编号，按号分配。所有进程对资源的请求必须严格按照资源序号递增的顺序提出。资源占用了小号资源才能申请大号资源。 缺点：限制了进程对资源的请求；预先对资源进行编号增加了系统开销；为遵循按编号申请的顺序，暂不使用的资源也需要提前申请，从而增加了进程对资源的占用时间。 死锁的避免（动态策略） 基本思想：预测发生死锁的可能性，确定资源分配的安全性。即不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。 系统是安全的，是指系统中的进程能够按照某一种次序分配资源，并且依次地运行完毕，这种进程序列{P1, P2, …, PN}就是安全序列。安全序列存在时一定不会有死锁发生（安全状态），但四个死锁的必要条件同时发生时（不安全状态）也未必会产生死锁。 银行家算法（详细分析见五） 死锁的检查与恢复 基本思想：系统为进程分配资源时，不采取任何限制性措施，但提供检测和解脱死锁的手段（能发现死锁并从死锁状态中恢复出来） (1) 检测（进程-资源分配图） a. 每种资源类中仅有一个资源的死锁检测检测有向图是否存在环（深度优先搜索+标记节点）b. 每种资源类中有多个资源的死锁检测简化分配图，看能否消去图中所有边，使所有进程成为孤立点 死锁定理：系统处于死锁条件的充分条件是当前仅当此状态的进程-资源分配图是不可完全简化的。 (2) 恢复 方法一：重启系统结束所有进程的执行并重新启动操作系统，会导致之前的工作全部作废 方法二：资源剥夺法剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除 方法三：进程回退法根据系统保存的检查点让所有进程回退，直到足以解除死锁 方法四：撤销进程法a. 撤销陷入死锁的所有进程，解除死锁，继续运行；b. 逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。撤销原则：CPU消耗时间最少者；产生的输出量最小者；预计剩余执行时间最长者；分得的资源数量最少者；进程优先级最低者 五、银行家算法 这是一个著名的避免死锁的算法，是有Dijstra首先提出并加以解决的。 算法的背景是，一个银行家如何将一定数目的资金安全地借给若干个用户，使这些客户既能拿到钱完成要干的事，同时银行家又能收回全部资金而不至于破产。 这个生活中的实际问题很像操作系统中的资源分配问题：银行家就是一个操作系统，客户就像运行的进程，而银行家的资金就是系统的资源。 让我们来具体规范地描述一下这个问题。 一个银行家拥有一定数量的资金，有若干个客户想要贷款，每个客户必须在一开始就声明他所需贷款的总额。若该客户贷款总额不超过银行家的资金总数，银行家可以满足客户的要求。客户不一定能一次性拿到自己所需的全部贷款，他在借满全部款额之前可能会等待，但银行家必须保证这种等待是有限的并且等待是有有结果的。 举个例子，假设银行家的资金总额为10个资金单位的，有三位客户C1、C2、C3向银行家借款，C1客户要借8个资金单位，C2客户要借4个资金单位，C3客户要借9个资金单位，总计21个资金单位。某一时刻的状态如下： （1）银行家已经借给C1客户4个资金单位、C2客户2个资金单位、C3客户2个资金单位，剩2个资金单位可分配 。 客户编号 已拥有的款额 还需要的款额 C1 4 4 C2 2 2 C3 2 7 （2）若将剩下的2个资金单位分配给C1或C3，就会形成如下情况： 客户编号 已拥有的款额 还需要的款额 C1 4或5或6 4或3或2 C2 2 2 C3 2或3或4 7或6或5 此后，C1、C2、C3中任何一位客户再提出申请都不能被满足，最后就可能产生死锁。 （3）若将剩下的2个资金单位分配给C2，则C2的贷款请求全部被满足，银行家此时可以收回C2已拥有的2个资金单位的款额，那么此时银行家拥有资金总额为4个资金单位。 客户编号 已拥有的款额 还需要的款额 C1 4 4 C3 2 7 （4）以此类推，接下来满足C1客户的请求，收回资金后银行家资金总额为8个资金单位，最后满足C3客户的请求。最终银行家可以收回全部10个资金单位的款额，且3位客户的需求都在有限等待时间内被满足，安全序列为{C2, C1, C3}。 综上，银行家算法是从当前状态出发，逐个按安全序列检查各客户谁能完成其工作，然后假定其完成工作且归还全部贷款，再进而检查下一个能完成工作的客户……如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的。 优点：允许互斥条件、请求与保持条件、不剥夺条件的存在，限制减少，资源利用率提高。 缺点：算法要求客户数固定不变，在多道程序系统中难以做到；仅能保证所有客户在有限时间内得到满足，不能满足实时客户要求快速响应的需求；需要寻找一个安全序列，增加了系统开销。 六、每种资源类中仅有一个资源的死锁检测算法 每个进程最开始时都不被标记，执行过程中有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。 举个例子，现在有三个进程四个资源，其中： E 向量：资源总量 A 向量：资源剩余量 C 矩阵：每个进程拥有的资源数量，每一行都代表一个进程拥资源的数量 R 矩阵：每个进程请求的资源数量 标记进程的顺序：P3→P2→P1资源剩余量变化：A=(2 1 0 0)→A=(2 2 2 0)→A=(4 2 2 1)→A=(4 2 3 1)3个进程P1、P2、P3均被标记了，则系统不会产生死锁 算法总结如下：Step1：寻找一个没有标记的进程Pi，它所请求的资源Step2：如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转回Step1Step3：如果没有这样一个进程，算法终止。 七、进程-资源分配图化简 算法步骤：Step1：先看系统还剩下多少资源没分配，再看有哪些进程是不阻塞的。其中，不阻塞指系统有足够的空闲资源分配给该进程；Step2：把不阻塞进程的所有边都去掉，形成一个孤立的点，再把系统分配给这个进程的资源回收回来；Step3：重复上述步骤，若最终所有的资源和进程都变成了孤立的点，则该图可完全简化。 举个例子，r1和r2分别表示两个不同的资源集，r1中共有三个可分配资源，r2中共有两个可分配资源。此时r1已经分配了2个资源给p1、1个资源给p2；r2已经分配了1个资源给p2。而p1又请求1个r2资源，p2又请求一个r1资源。 r1的3个资源已经全部分配完了，因此不能满足p2的请求，p2阻塞；r2还有1个可分配的资源，可以满足p1的请求。 去掉p1的所有边，即归还p1占据的2个进程给r1。p1此时成为一个孤立的点。同理，可以孤立出p2。 可见，该进程-资源分配图可以完全化简，即系统不会产生死锁。 powered by Gitbook最后修订时间： 2020-05-26 19:03:52 "},"Chapter2/操作系统/进程间通信方式.html":{"url":"Chapter2/操作系统/进程间通信方式.html","title":"进程间通信方式","keywords":"","body":"进程间通信方式 一、进程间通信的方式 无名管道：半双工通信方式，数据只能单向流动且只能在有亲缘关系的进程间使用 有名管道：半双工通信方式，允许在非亲缘关系的进程间使用 信号：通知接收进程某个事件已发生 消息队列：传递消息的链表，存放在内核中。克服了信号传输信息少，管道只能传输无格式字节流以及缓冲区大小受限的缺点 信号量：一个计数器，用来控制多个进程对共享资源的访问。常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源 共享内存：映射一份能被其他进程所访问的内存，这份内存由一个进程创建但其他进程可以访问 套接字：不同机器之间的进程通信 二、共享内存有什么缺点？如何解决？ 共享内存不提供同步机制，在使用共享内存进行通信时需要借助其他手段来进行进程间的同步工作，常与信号量一起使用实现同步对共享内存的访问。 powered by Gitbook最后修订时间： 2020-05-13 22:47:16 "},"Chapter2/操作系统/进程与线程.html":{"url":"Chapter2/操作系统/进程与线程.html","title":"进程与线程","keywords":"","body":"进程与线程 一、进程与线程的区别 进程是具有一定功能的程序，是系统进行资源分配调度的一个独立单位。 线程是进程的一个实体，是CPU调度分配的基本单位，线程之间基本上不拥有系统资源。 一个程序至少有一个进程，一个进程至少有一个线程，资源分配给进程，同一个进程下所有线程共享该进程的资源。 二、线程哪些资源共享？哪些资源不共享？ 共享：堆、全局变量、静态变量、文件等共用资源 独享：栈、寄存器 powered by Gitbook最后修订时间： 2020-05-13 22:42:57 "},"Chapter2/操作系统/并发与并行.html":{"url":"Chapter2/操作系统/并发与并行.html","title":"并发与并行","keywords":"","body":"并发与并行 并发：逻辑上的同时发生，强调有处理多个任务的能力但不一定要同时并行：物理上的同时发生，强调有同时处理多个任务的能力 打个比方，并发相当于一个人吃三个馒头，而并行相当于三个人吃三个馒头。而Erlang之父Joe Armstrong则用咖啡机和等待取咖啡的人来类比：并发是两条队列交替使用一台咖啡机，并行是两个队列同时使用两台咖啡机。 与可以一起出发的并发(concurrent)相对的是不可以一起出发的顺序(sequential) 顺序：上一个开始执行的任务完成后，当前任务才能开始执行 并发：无论上一个开始执行的任务是否完成，当前任务都可以开始执行 与可以一起执行的并行(parallel)相对的是不可以一起执行的串行(serial) 串行：有一个任务执行单元，从物理上就只能一个任务一个任务执行 并行：有多个任务执行单元，从物理上就可以多个任务一起执行 powered by Gitbook最后修订时间： 2020-05-14 11:49:02 "},"Chapter2/数据结构与算法.html":{"url":"Chapter2/数据结构与算法.html","title":"数据结构与算法","keywords":"","body":"数据结构与算法 常见排序算法的时间复杂度要熟悉，尤其是归并和快排，因为会让你手敲代码，敲完后很可能会顺势问问你时间空间复杂度。 树相关的内容前端里大概不怎么涉及，不过因为树是一种很重要的数据结构，还是放进来吧。 powered by Gitbook最后修订时间： 2020-05-26 15:35:38 "},"Chapter2/数据结构与算法/排序算法.html":{"url":"Chapter2/数据结构与算法/排序算法.html","title":"排序算法","keywords":"","body":"排序算法 先来看下常见排序算法的分类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 1、冒泡排序（Bubble Sort）冒泡排序是一种简单的排序算法，通过一趟又一趟地比较数组中的每一个元素，使较大的数据下沉，较小的数据上升。 2、选择排序（Selection Sort）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 3、插入排序（Insertion Sort）通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 4、希尔排序（Shell Sort）希尔排序是简单插入排序的改进版，通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。 5、归并排序（Merge Sort）归并排序的核心思想是分而治之（Divide and Conquer）：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 6、快速排序（Quick Sort）通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 7、堆排序（Heap Sort）堆排序是指利用堆这种数据结构所设计的一种排序算法。堆排序会将所有的数据建成一个堆，最大的数据在堆顶，然后将堆顶数据和序列的最后一个数据交换。接下来再次重建堆，交换数据，依次下去，就可以排序所有的数据。 8、计数排序（Counting Sort）计数排序核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 9、桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 10、基数排序（Radix Sort）基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 最后，附上算法复杂度的比较表： 稳定：a原本在b前面且a=b，排序之后a仍然在b的前面。 不稳定：a原本在b的前面且a=b，排序之后 a 可能会出现在 b 的后面。 注：n小时，冒泡排序、交换排序、选择排序比较适用；n大时，快速排序、归并排序、堆排序比较适用；对于大部分已排序好的数列，插入排序比较适用。 参考：十大经典排序算法（动图演示） 排序算法比较·面试宝典 powered by Gitbook最后修订时间： 2020-05-26 17:38:21 "},"Chapter2/数据结构与算法/动态查找树比较.html":{"url":"Chapter2/数据结构与算法/动态查找树比较.html","title":"动态查找树比较","keywords":"","body":"动态查找树比较 动态查找树主要有：二叉查找树、平衡二叉查找树、红黑树、B树，它们的特点是： 都是动态结构。在删除，插入操作的时候，都不需要彻底重建原始的索引树。最多就是执行一定量的旋转，变色操作来有限的改变树的形态。而这些操作所付出的代价都远远小于重建一棵树。 查找的时间复杂度大体维持在O(logN)数量级上。可能有些结构在最差的情况下效率将会下降很快，比如BST。 1、二叉查找树（Binary Search Tree，BST) 二叉查找树的发现完全是因为静态查找结构在动态插入、删除结点时需要付出很大代价。 BST 的操作代价分析： 查找代价任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。当树中每个结点左右子树高度大致相同时，树高为logN。则平均查找长度与logN成正比，查找的平均时间复杂度在O(logN)数量级上。当先后插入的关键字有序时，BST退化成单支树结构。此时树高n。平均查找长度为(n+1)\\/2，查找的平均时间复杂度在O(N)数量级上。 插入代价新结点插入到叶子结点时完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。 删除代价当删除一个结点P，首先需要定位到这个结点P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为O(1)。如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的...的右叶子结点与P互换，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过O(logN)。 BST效率总结 : 查找最好时间复杂度O(logN)，最坏时间复杂度O(N)；插入删除操作算法简单，时间复杂度与查找差不多。 2、平衡二叉查找树（Balanced Binary Search Tree/AVL) 二叉查找树在最差情况下和顺序查找效率相当，这是无法接受的。事实也证明，当存储数据足够大的时候，树的结构对某些关键字的查找效率影响很大。当然，造成这种情况的主要原因就是BST不够平衡(左右子树高度差太大)。既然如此，那么我们就需要通过一定的算法，将不平衡树改变成平衡树。因此，AVL树就诞生了。 AVL 的操作代价分析： 查找代价AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是O(logN)数量级的。 插入代价AVL必须要保证严格平衡(|bf| 删除代价AVL删除结点的算法可以参见BST的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子，因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。所以，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN) AVL效率总结 : 查找的时间复杂度维持在O(logN)，不会出现最差情况；AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右；AVL树在执行删除时代价稍大，执行每个删除操作的时间复杂度需要O(2logN)。 3、红黑树（Red-Black Tree，RBT） 二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度。而红黑树是一种折中策略，即不牺牲太大的建立查找结构的代价，也能保证稳定高效的查找效率呢。 RBT 的操作代价分析： 查找代价由于红黑树的性质(最长路径长度不超过最短路径长度的2倍)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。 插入代价RBT插入结点时，需要旋转操作和变色操作。但由于只需要保证RBT基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。 删除代价RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。 RBT效率总结 : 查找 效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些，但也远远好于BST；插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，删除最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)。虽然变色操作的时间复杂度在O(logN)，但是实际上，这种操作由于简单所需要的代价很小。 4、B树（B-Tree） 对于在内存中的查找结构而言，红黑树的效率已经非常好了。然而对于数据量非常大的查找，RBT结构显然是不实际的。像操作系统中的文件目录存储，数据库中的文件索引结构的存储.... 都不可能在内存中建立查找结构，而必须在磁盘中建立好这个结构。在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。频繁的磁盘IO操作，效率是很低下的，而B树就是为了解决这个问题。 B-Tree 的操作代价分析： 查找代价B-Tree作为一个平衡多路查找树(m-叉)，其查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。而且B+树作为B树的变种，其查找效率更高。 插入代价B-Tree的插入会发生结点的分裂操作。当插入操作引起了s个节点的分裂时，磁盘访问的次数为h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是h+2s+1，最多可达到3h+1。因此插入的代价是很大的。 删除代价B-Tree的删除会发生结点合并操作。最坏情况下磁盘访问次数是3h＝（找到包含被删除元素需要h次读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写访问）+（对修改过的根节点和第2层的两个节点进行3次写访问） B-Tree效率总结 : 由于考虑磁盘储存结构，B树的查找、删除、插入的代价都远远要小于任何二叉结构树(读写磁盘次数的降低)。 5、AVL和RBT的对比 结构对比 AVL的结构高度平衡，RBT的结构基本平衡。 查找对比 AVL 查找时间复杂度最好、最坏情况都是O(logN)；RBT 查找时间复杂度最好为O(logN)，最坏情况下比AVL略差。 插入删除对比 （1）AVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL。 （2）如果需要平衡处理时，RBT比AVL多一种变色操作，而且变色的时间复杂度在O(logN)数量级上。但由于操作简单，实践中这种变色仍是非常快速的。 （3）当插入一个结点都引起了树的不平衡，AVL和RBT都最多需要2次旋转操作。但删除一个结点引起不平衡后，AVL最多需要logN 次旋转操作，而RBT最多只需要3次。因此两者插入一个结点的代价差不多，但删除一个结点的代价RBT要低一些。 （4）AVL和RBT的插入删除代价主要还是消耗在查找待操作的结点上。因此时间复杂度基本上都是与O(logN) 成正比的。 总体评价：RBT的总体统计性能要好于平衡二叉树 6、B~树和B+树的对比 结构对比 B~树是平衡多路查找树，所有结点中都包含了待查关键字的有效信息(比如文件磁盘指针)。每个结点若有n个关键字，则有n+1个指向其他结点的指针。 B+树严格意义上说已经不是树，它的叶子结点之间也有指针链接。B+树的非终结点中并不含有关键字的信息，需要查找的关键字的全部信息都包含在叶子结点上。非终结点中只作为叶子结点关键字的索引而存在。 查找对比 （1）在相同数量的待查数据下，B+树查找过程中需要调用的磁盘IO操作要少于普通B~树。由于B树所在的磁盘存储背景下，因此B+树的查找性能要好于B~树。 （2）B+树的查找效率更加稳定，因为所有叶子结点都处于同一层中，而且查找所有关键字都必须走完从根结点到叶子结点的全部历程。因此同一颗B+树中，任何关键字的查找比较次数都是一样的。而B树就不一定了，可能查找到某一个非终结点就结束了。 插入删除对比 B+树与B~树在插入删除操作中的效率是差不多的 总体评价：在应用背景下，特别是文件结构存储中，B+树的应用要更多，其效率也要比B~树好。 参考： B-树 红黑树 二叉搜索树 AVL树比较 面试旧敌之红黑树（直白介绍深入理解）（红黑树的具体内容可以参考这篇博客） powered by Gitbook最后修订时间： 2020-05-26 16:15:39 "},"Chapter2/计算机网络.html":{"url":"Chapter2/计算机网络.html","title":"计算机网络","keywords":"","body":"计算机网络 这章主要介绍一些计算机网络中最最最最基本概念，也是最最最最高频的考点，一定得弄清原理、熟练表述出来。 HTTP相关的东西放到下一章单列出来了，这一章的内容有： 网络模型和网络协议 TCP握手挥手 TCP和UDP powered by Gitbook最后修订时间： 2020-05-26 13:14:35 "},"Chapter2/计算机网络/网络模型和网络协议.html":{"url":"Chapter2/计算机网络/网络模型和网络协议.html","title":"网络模型和网络协议","keywords":"","body":"网络模型和网络协议 一、OSI七层模型、TCP/IP概念层模型 区别：OSI模型注重通信协议必要的功能是什么，TCP/IP模型更强调在计算机上实现协议应该开发哪种程序。 二、应用层的网络协议 FTP：文本传输协议 SMTP：简单邮件传输协议 TELNET：Internet远程登录服务的标准协议和主要方式 HTTP：超文本传输协议 TFTP：简单文件传输协议 DNS：域名系统 SNMP：简单网络管理协议 NFS：网络文件系统 三、数据的单位 包：全能性术语 帧：数据链路层中包的单位 数据包：网络层以上的分层中包的单位 段：TCP数据流中的信息 消息：应用协议中数据的单位 四、地址 MAC地址：数据链路中的地址，用来识别同一链路中不同的计算机 IP地址：IP中的地址，用来识别连接到网络中的主机和路由器 程序地址（端口号）：识别同一台计算机中进行通信的不同应用程序 powered by Gitbook最后修订时间： 2020-05-14 16:37:00 "},"Chapter2/计算机网络/TCP挥手和握手.html":{"url":"Chapter2/计算机网络/TCP挥手和握手.html","title":"TCP握手挥手","keywords":"","body":"TCP握手挥手 首先，来认识一下握手挥手中用到的一些标识位和缩写的含义： SYN：标识位，表示建立链接 ACK：标识位，表示响应 FIN：标识位，表示关闭链接 seq：顺序号码（TCP连接中传送的字节流中的每个字节都按顺序编号） ack：确认号码，是期望收到对方下一个报文的第一个数据字节的序号 TCP三次握手：客户端和服务器都需要知道双方可收发，因此需要三次握手（让我知道你已经知道了） TCP客户端最后还要发送一次确认的目的：防止已经失效的连接请求报文突然又传送到服务器，从而导致不必要的错误和资源的浪费。 TCP四次挥手： TCP客户端最后还要等待2*MSL（最长报文段寿命）的目的：保证客户端发送的最后一个ACK报文能够达到服务器；防止已经失效的关闭连接报文段出现在本连接中。 Q1：如果已经建立了连接，但客户端突然出现故障怎么办？ TCP设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常设置为2h，若2h之内还没有收到客户端的任何数据，服务器就会发送一个探测报文，之后每隔75s发送一次。若连续发送10个探测报文仍没有回应，服务器就认为客户端出现故障，接着就关闭连接。 Q2：为什么建立连接是三次握手，关闭连接是四次挥手？ 建立连接的时候，服务器出于监听状态，一旦收到客户端建立连接请求的SYN报文后，可直接将SYN和ACK放在一个报文中返回客户端。 而关闭连接时，服务器收到客户端关闭连接的FIN报文时仅仅表示对方不再发送数据但仍能接受数据，而自己的数据也未必全部发送给对方了，所以此时发送完数据给对方后，再向客户端发送FIN报文来表示同意现在关闭连接，ACK和FIN的分开发送导致挥手比握手多了一次。 参考：两张动图-彻底明白TCP的三次握手与四次挥手（这篇博客讲的非常好，大家可以看看原文加深理解） powered by Gitbook最后修订时间： 2020-05-14 16:52:26 "},"Chapter2/计算机网络/TCP&UDP.html":{"url":"Chapter2/计算机网络/TCP&UDP.html","title":"TCP和UDP","keywords":"","body":"TCP和UDP 一、TCP和UDP的区别 TCP UDP 面向连接的可靠性传输 无连接不可靠 保证数据的无差错、不丢失、不重传且按序到达 尽最大努力交付，但不保证可靠交付 面向字节流 面向报文 只能是一对一 一对一或一对多 首部较大有20字节 首部只有8字节 用于需要可靠传输的情况 用于高速传输和对实时性有较高要求的通信（视频、音频等多媒体通信）或广播通信 TCP特点：流量控制、拥塞控制、面向连接、可靠传输 二、TCP滑动窗口和拥塞窗口比较 滑动窗口：发送方+接收方 解决发送方和接收方收发数据速率不一致的问题。滑动窗口相当于接收方的缓存，接收方向发送方通知自己可接受数据的大小，而发送方会根据这个数值发送数据 拥塞窗口：发送方 控制全局网络的拥塞情况。通过控制发送方每次发送的流量多少，来逐渐试探整体网络的拥塞程度。 如果没有拥塞控制，发送方每次发送的数据大小为滑动窗口，在只有两台主机的时候没有问题，但在现实的网络大环境中，如果每台主机都发送滑动窗口大小的数据，那整个网络系统必然会瘫痪，所以通过在发送方设置拥塞窗口，可以有效缓解网络压力。 三、TCP拥塞控制 慢启动+拥塞避免；快速重传+快速恢复 慢启动：防止一开始速率过快，导致耗尽中间路由器存储空间，从而严重降低TCP连接的吞吐量 拥塞避免：当拥塞发生时，降低网络传输速率 快速重传：在接收到相同ACK后，推断出丢失报文段起始序号，然后立即重传此报文 快速恢复：在快速重传基础上，如果发生了快速重传，则执行拥塞避免算法而非慢启动 powered by Gitbook最后修订时间： 2020-05-14 18:27:42 "},"Chapter2/JAVA.html":{"url":"Chapter2/JAVA.html","title":"JAVA","keywords":"","body":"JAVA 前言里提到我在正式准备面试前刷了一个半月的LeetCode，当时刷题的时候都是用JAVA来写的，语法库函数什么的都更熟悉一些，所以面试官每次让我写算法题的时候我就会问一嘴我能用JAVA写吗？（虽然就算法而言好像没那么大，但毕竟刷题时是用JAVA心里有底，JavaScript好久没实操了…）有些面试官会说都可以，但大部分面试官都说你还是用JS写吧，哪里不熟悉我告诉你。（面试官们基本上都是很nice的！） 不过因为告诉了面试官我前段时间刷题的时候都用JAVA写，他们有时候就会顺着问一些JAVA的问题。（感觉自己给自己挖了个坑）所以本章主要记录了一些我在面试过程中被问到的JAVA相关的问题，大家选择性地看看吧！ 本章内容梗概： 抽象类与接口 泛型 设计模式 powered by Gitbook最后修订时间： 2020-05-14 14:27:54 "},"Chapter2/JAVA/设计模式.html":{"url":"Chapter2/JAVA/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 一、单例模式（创建型模式） 单例类只能有一个实例；单例类必须自己创建自己的唯一实例；单例类必须给所有其他对象提供这一实例 目的：保证一个类仅有一个实例，并提供一个访问它的全局访问点 主要解决：一个全局使用的类频繁地创建与销毁问题 优点：内存中只有一个实例，节省系统资源，尤其是频繁创建和销毁实例；避免对资源的多重占用 缺点：没有接口，不能继承，与类的单一职责原则冲突（一个类只应该关心内部逻辑而不关心外部如何实例化） 二、观察者模式（行为型模式） 对象间存在一对多关系 目的：当一个对象被修改时，则会自动通知它的依赖对象 主要解决：一个对象状态改变给其他对象通知的问题，且要考虑易用和低耦合，保证高度的协作 优点：观察者和被观察者是依赖的（紧耦合） 缺点：观察者仅能知道目标对象发生了变化，而不知道是怎么发生变化的；如果观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能会导致系统崩溃；被观察对象如果有很多直接或间接的观察者的话，将所有观察者都通知到会花费很多时间 三、发布-订阅模式（广义上的观察者模式） 发布者和订阅者不知道对方的存在，需要一个第三方组件，即信息中介将订阅者和发布者串联起来，它过滤和分配所有输入的消息 四、发布-订阅模式与观察者模式的区别 观察者模式中，observer知道subject的存在，subject一直保持对观察者进行记录；发布-订阅模式中，publisher和subscriber不知道对方的存在，它们只有通过消息代理进行通信 观察者模式中，组件是紧耦合的；发布订阅模式中，组件是松散耦合的 观察者模式大多数时候是同步的，比如当事件触发，subject就会去调用观察者的方法；发布-订阅模式大多数时候是异步的（使用消息队列） powered by Gitbook最后修订时间： 2020-05-14 15:19:19 "},"Chapter2/JAVA/抽象类与接口.html":{"url":"Chapter2/JAVA/抽象类与接口.html","title":"抽象类与接口","keywords":"","body":"抽象类与接口 一、抽象类的特点 使用extends 关键字 抽象类是由子类具有相同的一类特征抽象而来，也可以说是其基类或父类 抽象方法必须为public或protected，默认为public 抽象类不能用来创建对象 抽象方法必须由子类来实现 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法；如果子类没有实现父类的抽象方法，则必须将子类也定义为抽象类 二、接口的特点 使用implements关键字 接口中所有方法访问权限自动被声明为public 实现接口的非抽象类必须实现接口中所有方法 接口不能创建对象，但可以声明一个接口变量，方便调用 Java为保证数据安全性不支持多继承，一个类只能有一个父类但可以同时实现多个接口，弥补了抽象类不能多继承的缺陷 三、抽象类和接口区别 抽象层次不同抽象类是对整个类整体进行抽象，包括属性、行为；接口对类局部行为进行抽象 跨域不同抽象类所跨域的是具有相似特点的类；接口可以跨域不同的类 抽象类体现继承关系，考虑的是子类和父类“是不是”同一类的关系；接口不要求实现的类与接口是同一本质，它们之间只存在“有没有这个能力”的关系 设计层次不同抽象类是自下而上的设计，在子类中重复出现的工作，抽象到抽象类中；接口是自上而下，定义行为和规范 powered by Gitbook最后修订时间： 2020-05-14 14:33:38 "},"Chapter2/JAVA/泛型.html":{"url":"Chapter2/JAVA/泛型.html","title":"泛型","keywords":"","body":"泛型 一、什么是泛型 泛型的本质是为了参数化类型，即在不创建类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。 泛型在使用的过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口、方法中，分别被称为泛型类、泛型接口、泛型方法。 举个例子，用JAVA创建List的时候，我们会使用 List list = new ArrayList(); 这里的ArrayList就是一个泛型类，通过设定<>中不同的类型，可以往集合里面存储不同类型的数据类型（只能存储泛型类设定的数据类型） powered by Gitbook最后修订时间： 2020-05-26 13:09:13 "},"Chapter3/README..html":{"url":"Chapter3/README..html","title":"HTTP/HTTPS/浏览器","keywords":"","body":"HTTP/HTTPS/浏览器 这一章节中的内容可以说是前端面试中的半壁江山，被问到的概率几乎可以和JavaScript平起平坐。其中有些题目基本上是技术面一面必问问题（技术一面通常考察一些最最最基本的基础知识），甚至在二面或三面中还会被反复问起，举个例子，比如： 在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？ 你能条理清晰、言简意赅地回答吗？ powered by Gitbook最后修订时间： 2020-05-22 22:40:05 "},"Chapter3/HTTP.html":{"url":"Chapter3/HTTP.html","title":"HTTP","keywords":"","body":"HTTP 一、HTTP常见状态码 按第一个数字分类：1表示信息，2表示成功，3表示重定向，4表示客户端错误，5表示服务器错误 状态码 含义 200 OK 请求成功。一般用于get和post请求 301 Moved Permanently 永久移动。请求的信息已经被移动到新的URI，会返回新的URI 302 Found 临时移动。资源只是临时被移动，客户端继续使用原URI 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码，不会返回任何资源 400 Bad Request 客户端请求的语法错误，服务器无法理解（产生原因：前端提交的数据在后台找不到与之相对应的实体） 401 Unauthorized 当前请求需要用户验证 403 Forbidden 服务器已经收到请求，但拒绝执行 404 Not Found 服务器无法根据用户的请求找到资源 500 Internal Server Error 服务器内部错误，无法完成请求 二、HTTP的首部有哪些？ 通用首部：表示一些通用信息，如date表示报文创建时间 请求首部：请求报文独有，如cookie、If-Modified-Since 响应首部：响应报文独有，如set-cookie、Last-Modified 实体首部：描述实体部分，如allow用来描述可执行的请求方法、content-type描述主体类型、content-Encoding描述主体的编码方式 三、HTTP支持的方法 方法 作用 get 请求指定的页面信息并返回响应主体，一般用于数据的读取 post 向指定资源提交数据，请求服务器去处理 head 获取服务器的响应头信息，常用于客户端查看服务器的性能 options 请求服务器返回该资源所支持的所有HTTP请求方法，常用于客户端查看服务器的性能 put 向指定资源位置上传其最新内容 delete 请求服务器删除所请求URI所标识的资源 connect 将连接改为管道方式的代理服务器，常用于SSL加密服务器与非加密的HTTP代理服务器的通信 trace 请求服务器回显其收到的请求信息，常用于HTTP请求的测试或诊断 四、get和post有什么区别？ get和post本质上就是TCP链接，并无差别，但由于HTTP的规定和浏览器、服务器的限制，导致它们在应用过程中有一些不同： get参数通过URL传递；post放在request body中 get请求在URL中传递的参数有长度限制；post没有（HTTP协议未规定，是因为浏览器和服务器的限制） get请求只能进行URL编码；post请求有多种编码方式 get请求参数会被完整保留在浏览历史记录里；post中的参数不会被保留 get产生一个TCP数据包；post产生两个TCP数据包 对于get请求，浏览器将http header和data一并发送，服务器响应200 OK；对于post请求，浏览器先发送header，服务器响应100 Continue，浏览器再发送data，服务器响应200 OK 缓存方面：get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存；post请求一般做的是修改和删除工作，必须与数据库交互，所以不能使用缓存 五、http2.0的新特点 基于HTTPS天然具有安全性 二进制分帧层：将所有传输信息分割成更小的信息或帧，并进行二进制编码（http2.0性能增强核心） 允许多路复用：基于二进制分帧层，在共享TCP连接的基础上，同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，交错发送出去，最后在另一端根据流ID和首部将他们重新组合起来 服务器推送：服务端根据客户端的请求，提前返回多个响应，推送额外的资源给客户端，支持缓存（遵循同源策略；基于客户端的请求响应来确定的） 六、HTTP缓存机制 两种缓存方式，根据响应的header内容来决定 强缓存（状态码：200）：浏览器不向服务器发送任何请求，直接从本地缓存中读取文件并返回（相关字段：Cache-Control、Expires） 协商缓存（状态码304）：浏览器发送请求到服务器，通过服务器来告知缓存是否可用（相关字段：Last-Modified/If-Modified-Since、Etag/If-None-Match） 缓存相关headerCache-Control、Expires、Last-Modified/If-Modified-Since、Etag/If-None-Match 流程 参考：面试精选之http缓存 powered by Gitbook最后修订时间： 2020-05-15 10:33:50 "},"Chapter3/HTTPS.html":{"url":"Chapter3/HTTPS.html","title":"HTTPS","keywords":"","body":"HTTPS 一、HTTPS工作原理 客户端通过URL发起HTTPS请求，要求服务器建立SSL链接 服务器收到客户端的请求后，返回公钥证书 客户端验证公钥证书是否有效，验证不通过则显示警告信息；验证通过则利用伪随机数生成器生成会话密钥，然后用证书的公钥加密会话密钥并发送给服务器 服务器通过自己的私钥解密会话密钥。至此，客户端和服务器双方都持有了相同的会话密钥 服务器和客户端之间通过会话密钥加密双方间的通信 二、HTTPS加密方式 HTTPS使用非对称加密传输一个对称密钥，服务器和客户端使用这个对称密钥来加密解密收发数据；而具体传输数据则是用对称加密的方式。 对称加密DES：加密和解密使用同一个密钥（速度快） 非对称加密RSA：发送端使用公开的公钥加密，接收端使用私密的私钥解密（安全） 三、HTTPS优点和缺点 优点 能够进行信息加密、完整性校验和身份验证，很大程度上避免了HTTP协议容易发生信息窃听、信息篡改、信息劫持的风险。 缺点 握手阶段比较费时，会使页面加载时间延长，增加耗电 HTTPS缓存不如HTTP高效，会增加数据开销 SSL证书需要费用，功能越强大的证书费用越高 SSL证书需要绑定IP，不能在同一个IP上绑定多个域名，ipv4资源支持不了这种消耗 四、HTTPS和HTTP的区别 HTTP：超文本传输协议，TCP协议的一种，用于从WWW服务器传输超文本到本地浏览器的一种网络协议 HTTPS：HTTP+SSL，是HTTP的安全版，加入SSL层实现加密传输和身份认证 区别 HTTP传输的数据是未加密的，即明文传输；HTTPS是具有安全性的SSL加密传输协议 HTTPS需要使用SSL证书；HTTP不用 端口号不同，HTTP端口号80；HTTPS端口号443 HTTPS基于传输层；HTTP基于应用层 五、HTTPS中间人攻击及其防范 MITM中间人攻击：攻击者相当于一个介入通信的传话员，攻击者知道通信双方的所有通信内容且可以任意增加、删除、修改双方的通信内容，而双方对此并不知情。 通信过程安全性的保证（自下而上） 公钥的正确性：双方通信采用非对称加密的方式，非对称加密中私钥不会传递，而公钥是公开的 。 数字证书的正确性：公钥由对方在通信初始提供，但很容易被中间人替换，因此发送公钥的时候也要提供对应的数字证书，用于验证公钥来自于对方而不是中间人。 上级CA证书的正确性：数字证书由上级CA签发给个人或组织，上级CA用自己的私钥给个人证书签名，保证证书的公钥不被篡改。 根证书的私钥不被泄露或其公钥不被篡改：上级CA证书也是由其上级CA签发的，这条信任链一直延续到根证书，而根证书是自签名的。 设备分发到消费者手中之前不被恶意修改：根证书一般通过操作系统而非网络分发；最初的操作系统应采用原始的当面交流的方式分发。因此，硬件厂商和证书签发机构合作，在设备出厂前在其操作系统中内置签发机构的根证书。 参考：HTTPS 中间人攻击及其防范 powered by Gitbook最后修订时间： 2020-05-15 09:51:35 "},"Chapter3/浏览器.html":{"url":"Chapter3/浏览器.html","title":"浏览器","keywords":"","body":"浏览器 一、什么是URL URL指的是统一资源定位符，即一个给定的独特资源在Web上的地址 组成部分： protocol：协议，表明浏览器必须使用何种协议 domain：域名，表示正在请求哪个服务器 port：端口 path：网络服务器上资源的路径 parameters：提供给网络服务器的额外参数 anchor：资源本身的另一部分的锚点，锚点表示资源中的一种“书签”，给浏览器显示位于该“加书签”位置的内容的方向 二、什么是BOM？有哪些常用BOM对象及其属性？ BOM是浏览器对象 location对象：用于获取或设置窗体的URL，并且可以用于解析URL 属性 描述 hash 设置或返回从井号(#)开始的URL(锚) host 设置或返回主机名和当前URL的端口号 hostname 设置或返回当前URL的主机名 href 设置或返回完整的URL pathname 设置或返回当前URL的路径部分 port 设置或返回当前URL的端口号 protocol 设置或返回当前URL的协议 search 设置或返回从问号(？)开始的URL(查询部分) history对象：记录用户曾经浏览过的页面（URL），并可以实现浏览器的前进与后退相似导航功能 属性 描述 length 返回浏览器历史列表中的URL数量 方法 描述 back() 加载history列表中的前一个URL forward() 加载history列表中的下一个URL go() 加载history列表中的某个具体的页面 navigator对象：包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本 属性 描述 appCodeName 浏览器代码名的字符串表示 appName 返回浏览器的名称 appVersion 返回浏览器的平台和版本信息 platform 返回运行浏览器的操作系统平台 userAgent 返回由客户端发送服务器的user-agent头部的值 三、Cookie作用 保存用户登录状态：一段时间内免登录 跟踪用户行为：天气预报网站中保存用户上次访问时的地区；有换肤功能的网站保存用户上次访问的界面风格 四、Cookie有哪些字段可以设置？ name：cookie的名称 value：cookie的值（文本数据） domain：可以访问此cookie的域名 path：可以访问此cookie的页面路径 expires/max-age：cookie过期时间 size：cookie的大小 httponly：true则只有在http请求头中会带有此cookie信息，而无法通过js脚本来访问cookie secure：是否只能通过HTTPS来传递此条cookie 五、Cookie和Session的共同点和区别？ 共同点：都是用来跟踪浏览器用户身份的会话方式 区别： cookie数据保存在浏览器，session数据保存在服务器 cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑安全性使用session session会在一定时间内保存在服务器上，当访问增多是会占用服务器性能，考虑性能使用cookie 六、cookie，localStorage，sessionStorage的共同点和区别 共同点： 都是前端本地存储的方式，均保存在浏览器端且同源 区别： 数据和服务器之间的交互方式cookie可以在客户端和服务器之间来回传递localStorage和sessionStorage不会主动把数据发送给服务器，仅在本地保存。 生命周期cookie在设置的有效期到期前都有效，默认是关闭浏览器后失效sessionStorage仅在当前网页会话下有效，关闭页面或浏览器后失效localStorage除非被手动清除，否则始终有效，永久保存 存放数据大小cookie存储容量较小，一般只有4KBlocalStorage和sessionStorage可以保存5MB的信息 作用域cookie和localStorage在所有同源窗口都是共享的sessionStorage不在不同的浏览器窗口中共享 七、CSRF和XSS攻击及防御手段 名称 方式 防御手段 CSRF(跨站请求伪造) 攻击者在页面中嵌入恶意JS脚本，当用户浏览该页面时进行攻击 cookie设置httponly和secure；进行特殊字符过滤；对用户的输入进行检查 XSS(跨站脚本攻击) 攻击者盗用用户身份，以用户名义发送恶意请求 使用验证码；检查HTTPS头部referer字段 八、Cookie如何防范XSS攻击？ 在http头部配上set-cookie，其中 httponly：该属性会禁止JS脚本使用document.cookie来访问cookie secure：该属性告诉浏览器仅在请求为HTTPS的时候才发送cookie 九、在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？ 简答 DNS解析→TCP连接→发送HTTP请求→服务器处理请求并返回HTTP报文→浏览器解析渲染页面→连接结束 详细叙述 根据URL域名寻找服务器ip，浏览器首先在缓存中查找，查找的顺序是浏览器缓存→系统缓存→路由器缓存，缓存中查找不到则去系统的hosts文件中查找，没有则查询DNS服务器 得到ip地址后，浏览器根据ip和相应端口号构建一个http请求并将该http请求封装在一个tcp包中，这个tcp包依次经过传输层、网络层、数据链路层、物理层到达服务器，服务器解析这个请求并作出响应，返回相应的html给浏览器 浏览器根据返回的html来构建DOM树，构建DOM树的过程中如果遇到图片、音视频等资源会并行下载，如果遇到js脚本或外部js连接，则会停止DOM树的构建去执行和下载相应js脚本，这会造成阻塞；之后根据外部样式、内部样式、内联样式构建CSSOM树，构建完成后和DOM树合并成渲染树，主要目的是排除非视觉节点，比如script、meta标签和排除display为none的节点 进行布局，确定各个元素的位置和尺寸，然后渲染页面，显示给用户 上述所有请求中都会涉及http缓存机制 十、浏览器在生成页面时会生成哪两棵树？ DOM树 CSSOM规则树 当浏览器接收到服务器返回的HTML文档后，会遍历文档节点，生成DOM树；CSSOM规则树由浏览器解析CSS文件生成。 十一、前端优化/Web性能优化 降低请求量：合并资源、减少HTTP请求数、gzip压缩 加快请求速度：减少域名数、并行加载、预解析DNS 缓存：HTTP缓存机制、离线数据缓存localStorage 渲染：使用外部JS和CSS、加载顺序（将CSS样式表放在顶部，JS脚本放在底部）、图片懒加载 十二、什么是重排/回流（reflow）和重绘（repaint）？哪些情况会引起重排重绘？怎样减少重排重绘？ 重排：部分或整个渲染树需要重新分析并且节点尺寸需要重新计算 重绘：由于节点的几何属性发生改变或者样式发生改变，屏幕上的部分内容需要更新 引起重排重绘的原因（重排一定重绘，重绘不一定重排）：任何改变用来构建渲染树的信息都会导致一次重排或重绘 浏览器初始化窗口 添加或删除可见的DOM元素 移动或者给页面中的DOM节点添加动画 添加一个样式表，调整样式属性 用户行为，如调整窗口大小、改变字号、滚动等 减少重排重绘的方法： 批量改变和表现DOM：复制即将更新的节点，在副本上操作，然后将旧的节点和新的节点交换；通过display：none属性隐藏元素，添加足够多的变更后，通过display属性显示（只触发两次重排重绘） 使用cssText（动态改变）、className（静态改变）一次性改变属性 对于多次重排的元素，比如动画，使用绝对定位使其脱离文档流，不影响其他元素 十三、图片的懒加载和预加载 预加载：提前加载图片，当用户需要时可直接从本地缓存中渲染 懒加载/延迟加载：访问页面时先把图片替换成一张占位图，当图片出现在浏览器可视区域时，才显示真正的图片内容 十四、什么是按需加载？ 用户触发了动作时才加载对应的功能 触发的动作：鼠标点击、键盘输入、鼠标移动、窗口大小更改、拉动滚动条等加载的文件：HTML、CSS、JS、图片等 powered by Gitbook最后修订时间： 2020-05-26 18:17:19 "},"Chapter4/":{"url":"Chapter4/","title":"HTML","keywords":"","body":"HTML 一、HTML5新增内容 新语义化标签：header、footer、nav、section、aside、article、main、figure 新增input类型：color、url、email、date、week、time、number、range、search、tel 新增表单控件属性：placeholder/设置文本框默认提示文字、autofocus/自动获得焦点、autocomplete/联想关键词 存储：提供了sessionStorage、localStorage和本地离线存储（使用manifest配置文件） 多媒体：音频元素audio、视频元素vedio、source、embed 地理定位、canvas画布、拖放API、多线程编程的webworker、websocket协议 二、Doctype有什么作用？有哪几种模式？ Doctype声明在文档的最前面，告诉浏览器以哪种方式来渲染页面： 严格模式：排版和JS运作模式是以该浏览器支持的最高标准运行的混杂模式：向后兼容，模拟老式浏览器，防止浏览器无法兼容页面 三、什么是iframe？有什么缺点？ iframe元素会创建包含另一文档的内联框架 缺点： 会阻塞主页面的onload事件 搜索引擎无法解读这种页面 主页面和iframe共享连接池，而浏览器对相同区域有限制，所以会影响性能 四、什么是WebSocket？有什么特点？ WebSocket是HTML5中新增的协议，支持持久性连接，解决了HTTP协议通信只能由客户端发起的缺陷。 特点： 服务器可以主动向客户端发送信息，客户端也可以主动向服务器发送信息，实现了双向平等对话 建立在TCP协议之上，服务端的实现比较容易 与HTTP协议有着良好的兼容性。默认端口也是80和443，握手阶段采用HTTP协议，因此不容易屏蔽，且能通过各种HTTP代理服务器 数据格式（帧）比较轻量，性能开销小，通信效率高 可以发送文本或二进制数据 无同源限制，客户端可以与任意服务器通信 协议标识符是ws（加密则为wss），服务器网址就是URL 参考：WebSocket协议：5分钟从入门到精通 五、WebSocket连接如何建立？ 客户端通过http请求与WebSocket服务端协商升级协议，协议升级完成后，后续的数据交换遵照WebSocket的协议。 客户端申请协议升级，采用标准HTTP报文格式，且只支持GET方法 请求首部： Connection: Upgrade 表示要升级协议 Upgrade: websocket 表示要升级到websocket协议 Sec-WebSocket-Version 表示websocket版本 Sec-WebSocket-Key 与后续服务端响应首部Sec-WebSocket-Accept配套，提供基本的防护，如恶意的连接或无意的连接 服务端响应协议升级，返回如下内容，状态代码101表示协议切换。至此完成协议升级，后续的数据交互都按照新协议来 Connection: Upgrade Upgrade: websocket Sec-WebSocket-Accept 根据Sec-WebSocket-Key计算 六、HTML5的拖放API 在HTML5之前，如果要实现拖放效果，一般会使用mousedown、mousemove和mouseup三个事件进行组合来模拟出拖拽效果，比较麻烦。而HTML5规范实现了原生拖放功能，使得元素拖放的实现更加方便和高效。 dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发 drag：事件主体是被拖放元素，在正在拖放被拖放元素时触发 dragenter：事件主体是目标元素，在被拖放元素进入目标元素时触发 dragover：事件主体是目标元素，在被拖放元素在目标元素内移动时触发 dragleave：事件主体是目标元素，在被拖放元素移出目标元素时触发 drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发 dragend：事件主体是被拖放元素，在整个拖放操作结束时触发 powered by Gitbook最后修订时间： 2020-05-24 16:02:07 "},"Chapter5/":{"url":"Chapter5/","title":"CSS","keywords":"","body":"CSS 一、盒子模型 标准盒子模型：width=content 盒子宽度=width+padding+border IE盒子模型：width=content+padding+border 盒子宽度=width 二、设置一个元素的背景颜色，背景颜色会填充哪些区域？ background-color设置的背景颜色会填充元素的content、padding和border区域 三、CSS有哪些选择器？优先级如何？ id选择器、类选择器、标签选择器、伪类选择器、伪元素选择器、通用选择器（*） 内联样式>id选择器>类选择器>标签选择器 带有!important标记的样式属性优先级最高 四、根据样式表来源划分的优先级 内联样式>内部样式>外部样式>浏览器用户自定义样式>浏览器默认样式 五、@import和link标签作用和区别 作用：都用来引入CSS样式 区别： @import由CSS提供；link属于HTML标签 @import只有IE5+才能识别；link不存在兼容性问题 页面被加载时，link会同时被加载；@import会等到页面加载结束后加载 link权重高于@import 六、CSS3新增内容 CSS3边框：border-radius、box-shadow、border-image CSS3背景：background-size、background-origin（规定背景图片定位区域） CSS3文字效果：text-shadow、word-wrap（对长单词进行拆分并换行） CSS3 2D转换：transform: translate()、rotate()、scale() CSS3 3D转换：transform: rotateX()、rotateY() CSS3 过渡：transition CSS3 动画：animation CSS3用户界面：resize（是否可由用户调整元素尺寸）、box-sizing（定义盒模型） 七、隐藏页面中某个元素的方法？ opacity=0；visibility=hidden；display：none；position移到外部；z-index图层遮盖 八、visibility=hidden, opacity=0, display:none区别 opacity=0：元素透明度为0，该元素被隐藏起来，但不会改变页面布局，如果该元素已经绑定一些事件，仍能触发 visibility=hidden：元素不可见但仍然存在，不会改变页面布局，但不会触发该元素已经绑定的事件 display:none：元素不显示并且会改变页面布局，可理解为该元素从页面中被删除 九、z-index定位方法 z-index只能在定位元素上奏效，该属性设置一个定位元素沿z轴的位置，如果为正数，离用户越近；为负数，离用户越远。默认值为auto，即堆叠顺序和父元素相等。其他属性值有number、inherit 十、CSS动画如何实现？transition和animation的区别 使用animation创建动画序列，该属性允许配置动画时间、时长以及其他动画细节，但不能配置动画的实际表现，动画的实际表现由@keyframes规则实现 使用transition实现，transition强调过渡，是元素的一个或多个属性发生变化时产生的过渡效果，同一个元素通过两个不同的途径获取样式，而当第二个途径发生某种改变时才会产生过渡动画 区别： transition需要触发一个事件才能改变属性；animation不需要触发任何事件就会随时间改变属性 transition为2帧（from…to…）；animation可以一帧一帧的 参考：CSS3 Transitions, Transforms和Animation使用简介与应用展示 十一、transition有哪些属性？ transition-property：指定过渡的属性值 transition-delay：指定延迟过渡时间 transition-duration：指定过渡持续时间 transition-timing-function：指定过渡动画缓动类型（ease-out/快-慢、ease-in/慢-快、ease-in-out/慢-快-慢、liner线性过渡、cubic-bezier贝塞尔曲线等） 十二、js动画和css3动画区别 优点 缺点 js动画 可在动画播放过程中对其进行开始、暂停、回放、终止、取消等控制；动画效果丰富，可以实现一些复杂效果，如视差滚动等；不存在兼容性问题 干扰主线程导致阻塞，造成丢帧情况；代码复杂度高 css3动画 浏览器会对CSS3动画进行优化；代码相对简单 CSS3动画只能暂停，运行过程控制较弱，无法附加事件绑定回调函数；代码冗长，部分动画无法实现；兼容性不好 十三、position有哪些属性？ 属性 说明 fixed(固定定位) 元素位置相对于浏览器窗口是固定的，即使窗口滚动也不会移动。fixed定位使元素脱离文档流，因此不占据空间。fixed定位元素会和其他元素重叠。 absolute(绝对定位) 元素位置相对于最近的已定位父元素，若没有则相对于html。absolute定位使元素位置脱离文档流，因此不占据空间。absolute定位元素和其他元素重叠。 relative(相对定位) 相对定位的元素将出现在它所在的位置上，然后可通过top、bottom、right、left让这个元素相对于它的初始位置移动。使用相对定位时无论元素是否移动仍占据原来空间，因此，移动元素会导致它覆盖其他框。 sticky(粘性定位) 元素先按普通文档流进行定位，然后相对于该元素在流中的flow root（BFC）和containing block（最近块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。 static(默认定位) 默认值，没有定位。元素出现在正常的流中（忽略top、bottom、right、left、z-index声明） inherit 继承父元素的position属性值 十三、inline-block、inline和block的区别？ block：块级元素，前后都有换行符，可设置width和height，padding和margin水平垂直方向均有效 inline：内联元素，前后无换行符，在一排排列，不可设置width和height，垂直方向上padding和margin失效 inline-block：内联块级元素，可设置width和height，padding和margin水平垂直方向均有效，前后无换行符 十四、为什么img是inline还可以设置宽高 img属于替换元素，替换元素一般有内在尺寸和宽高比，所以具有width和height，可设定 HTML中的替换元素：img、input、textarea、select 十五、三种文档流 普通流 普通流中，盒子一个接着一个排列 块级格式化上下文里，盒子竖着排列；行内格式化上下文中，盒子横着排列 当position为static或relative，并且float为none时会触发普通流 position：static，盒的位置是常规流布局里的位置 position：relative，盒偏移位置由top、bottom、left、right属性定义。即使有偏移，仍然保留原有位置，其他常规流不能占用这个位置 定位流 盒从常规流中被移除，不影响常规流的布局 当position为fixed或absolute时为绝对定位元素 position：absolute，元素定位将相对于上级元素中最近的一个relative、fixed、absolute，如果没有则相对于body 浮动流 左浮动元素尽量靠左靠上，右浮动同理 除非设置clear，否则普通流环绕在其周围 浮动元素不影响块级元素的布局，但会影响行内元素的布局，让其围绕在自己周围，撑大父级元素，从而间接影响块级元素布局 浮动元素最高点不超过当前行的最高点和其前面的浮动元素的最高点；不超过它的包含块，除非元素本身已经比包含块更宽 行内元素只出现在左浮动元素的右边或右浮动元素的左边 十六、页面布局方式 方式 布局特点 设计方法 缺点 静态布局（Static Layout） 无论浏览器尺寸具体多少，网页布局始终按照最初写代码时的布局来实现 居中布局，所有样式使用绝对宽度和高度px；屏幕宽高调整时通过滚动条来浏览被遮掩部分 不能根据用户的屏幕尺寸做出不同表现 流式布局（Liquid Layout） 屏幕分辨率变化时，页面内元素的大小会变化而布局不变；屏幕太大或太小都会导致元素无法正常显示 使用%定义宽度，px定义高度，配合max-width/min-width控制尺寸流动范围以免过大或过小影响阅读 如果屏幕尺寸跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示 自适应布局（Adaptive Layout） 屏幕分辨率变化时，页面内元素的位置会变化而大小不会变化 创建多个静态布局，每个静态布局对应一个屏幕分辨率范围，屏幕分辨率改变时，切换不同的静态布局（通过@media媒体查询给不同尺寸的设备切换不同样式） 需要需要为不同的设备开发不同的页面，增加开发成本；当需求改变时可能会改动多套代码，流程繁琐。 响应式布局（Responsive Layout） 每个屏幕分辨率下会有一个布局样式，即屏幕分辨率变化时，元素位置和大小都会变 @media媒体查询+流式布局 媒体查询是有限的，只能适应主流媒体的宽高 弹性布局（rem/em布局） 包裹文字的各元素的尺寸采用rem/em做单位（em相对其父元素，rem始终相对html大小，即页面根元素），页面主要划分区域的尺寸仍使用百分数或px 一般使用rem，根据屏幕大小来控制html元素的font-size，即可自动改变所有用rem定义尺寸的元素的大小 只做到了宽度自适应，无法满足一些对高度或者元素间距要求较高的设计 流式布局VS响应式布局 流式布局用于解决类似的设备不同分辨率之间的兼容（分辨率差异较小）；响应式布局用于解决不同设备之间不同分辨率的兼容（分辨率差异较大） 自适应布局VS响应式布局 共同点：检测设备，根据不同设备采用不同CSS，且CSS都采用百分比确定宽度 区别：响应式布局在不同设备上看上去是不一样的，会随着设备的改变而改变展示样式；自适应布局在所有的设备上看上去是一样的模板，不过是长度或者图片变小了 参考：静态布局、自适应布局、流式布局、响应式布局、弹性布局等的概念和区别 十七、BFC定义、触发条件（哪些元素会生成BFC）、约束规则、作用 定义：BFC块级格式化上下文，用于决定块盒子的布局及浮动相互影响范围的一个渲染区域 触发方式/哪些元素会生成BFC 根元素，即HTML标签 浮动元素：float值为left或right 定位元素：position为fixed或absolute的元素 overflow值不为visible，为auto、scroll、hidden的元素 display值为inline-block、table-cell、table-caption、flex、inline-flex的元素 约束规则 内部的box会在垂直方向上一个接一个放置 内部的box垂直方向上的距离由margin决定 每个元素的左外边距与包含块的左边界相接触，即使浮动元素也如此 BFC的区域不会与float的元素区域重叠 计算BFC高度时，浮动元素也参与计算 作用 阻止元素被浮动元素覆盖 可以包含浮动元素 阻止因浏览器四舍五入造成的多列布局换行的情况 阻止相邻元素margin合并 十八、什么是浮动溢出？如何清除浮动？ 在非IE浏览器下，当容器的高度为auto，且容器中有浮动元素（float为left或right）时，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响甚至破坏布局。 CSS清除浮动方法： 在浮动元素后使用一个带clear属性的空元素 给浮动元素的容器添加overflow：hidden属性 使用:after伪元素 参考：CSS技巧（一）：清除浮动 十九、垂直居中方法 不知道子元素的宽度和高度 容器display:flex; justify-content:center; align-items:center; 知道子元素的宽度和高度 容器position:relative;子元素position:absolute; top:50%; left:50%; transform: translateX(-50%) translateY(-50%); 容器position:relative;子元素margin:auto; top:0; right:0; bottom:0; left:0; 二十、flex布局 flex布局，用来为盒模型提供最大灵活性（任何一个容器都可以指定为flex布局，设为flex布局后子元素的float、clear和vertical-align属性将失效） flex容器（flex container）+flex项目（flex item） 注：水平轴为主轴（main axis），项目默认沿主轴排列 flex container属性（6个） flex-direction：决定主轴方向，即项目的排列方向 flex-wrap：如果一条轴线排不下如何换行 flex-flow：flex-direction + flex-wrap justify-content：定义项目在主轴上的对齐方式 align-items：定义项目在交叉轴上的对齐方式 align-content：定义多跟轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 flex item属性（6个） order：定义项目排列顺序，数值越小排列越靠前，默认为0 flex-grow：定义项目放大比例，默认为0（如果存在剩余空间也不放大） flex-shrink：定义项目缩小比例，默认为1（如果空间不足缩小该项目），负值对该属性无效 flex-basis：定义在分配多余空间之前，项目占据的主轴，默认auto（项目本来大小） flex：flex-grow + flex-shrink + flex-basis align-self：允许单个项目与其他项目不一样的对齐方式，可覆盖align-items，默认auto（继承父元素align-items属性，无父元素则等同于stretch） 参考：Flex 布局教程：语法篇 二十一、grid布局 grid网格布局，它将页面划分成一个个网格，可以任意组合不同的网格。由容器和项目两部分组成，容器默认为块级元素，也可以通过inline-grid设置为行内元素；项目只能是容器的顶层子元素，不包含项目的子元素（设为网格布局后，容器子元素的float、display:inline-block | table-cell、vertical-align和column-*等设置都将失效） 参考：CSS Grid 网格布局教程（grid布局的属性比较多，这里不具体列出来了，大家可以参考阮老师的这篇博客） 二十二、grid布局和flex布局的区别 flex布局是轴线布局，只能指定items针对轴线的位置，可以看作是一维布局；grid布局则是将容器划分为行和列，产生单元格，然后指定items所在的单元格，可以看作是二维布局。 powered by Gitbook最后修订时间： 2020-05-26 17:58:34 "},"Chapter6/":{"url":"Chapter6/","title":"JavaScript /ES6","keywords":"","body":"JavaScript/ES6 一、JS数组常用方法 方法 说明 push() 添加元素到数组末尾 pop() 删除数组末尾元素 unshift() 添加元素到数组的头部 shift() 删除数组最前面元素 indexOf() 查看某个元素在数组中的位置 splice(start, num, value) 实现增删改操作（start开始下标，num删除元素个数，value插入或替换的元素） slice(begin, end) 浅拷贝数组并返回拷贝后的新数组 Array.from() 从一个类似数组或可迭代对象中创建一个新的数组实例 fill(value, start, end) 用一个固定值填充数组中[start,end)的全部元素 二、mouseover和mouseenter的区别 mouseover/mouseout：当鼠标移入元素或其子元素都会触发事件，有一个重复触发的冒泡过程 mouseenter/mouseleave：当鼠标移入元素本身（不包含元素的子元素）会触发事件，即不会冒泡 三、clientHeight, scrollHeight, offsetHeight ,以及scrollTop, offsetTop, clientTop的区别？ clientHeight：可视区域高度，不包含border和滚动条offsetHeight： 可视区域高度，包含border和滚动条scrollHeight：所有区域高度，包含因滚动被隐藏的部分clientTop：边框border的厚度scrollTop：滚动后被隐藏的高度，获取对象最顶端与窗口中可见内容最顶端之间的距离offsetTop：获取指定对象相对于版面或布局中设置position属性的父容器顶端位置的距离 四、JS类型判断 typeof A、A instanceof B、Object.prototype.toString.call (A) 注意：数组判断不能用typeof（typeof只能判断是否是object） 五、如何获得对象上的属性 for(let l in obj)：遍历一个对象及其原型链中所有可枚举的属性 object.keys：返回一个包含所有可枚举的属性名称的数组 object.getOwnPropertyNames：返回一个包含不可枚举的属性的数组（基本包装类型的原型属性不可枚举，如Object、Array、Number等） 六、JS语言特点 运行在客户端浏览器上 不用预编译，直接解析执行代码 弱类型语言，较为灵活 与操作系统无关，跨平台 脚本语言、解释性语言 七、JS中string的startswith和indexof两种方法的区别 str.startsWith(searchString, position)searchString：要搜素的子字符串position（可选）：搜索searchString的开始位置，默认为0能找到返回true，找不到返回false str.indexOf(searchValue, fromIndex)searchValue：要搜索的字符串fromIndex（可选）：开始查找的位置，默认为0没找到返回-1，否则返回searchValue第一次出现的索引 八、ES6有哪些新特性？ 新增let、const声明变量，实现了块级作用域 新增箭头函数 引入promise、await/async解决异步回调问题 引入Class作为对象的模板，实现更好的面向对象编程 引入模块方便模块化编程 引入新的数据类型symbol，新的数据结构set和map 九、let、const、var区别 类型 变量提升 暂时性死区 重复声明 初始值 作用域 var 存在 不存在 允许 不需要 全局作用域、函数作用域 let 不存在 存在 不允许 不需要 块级作用域 const 不存在 存在 不允许 需要 块级作用域 变量提升：变量可在声明前使用暂时性死区：代码块内，使用let、const声明变量之前，该变量都是不可用的 十、==和===、以及Object.is的区别 ==：两边值类型不同时，强制转换成number再进行比较（null==undefined→true） ===：严格比较运算符，不会进行强制类型转换（+0===-0 true；NaN===NaN false） Object.is()：与===基本一致（Object.is(+0,-0) false；Object.is(NaN,NaN) true） 十一、setTimeout、setInterval和requestAnimationFrame 名称 说明 setTimeout/clearTimeout 延时执行参数指定代码 setInterval/clearInterval 每隔一段时间执行指定代码 requestAnimationFrame 在浏览器每次刷新页面之前执行：1. 会把每一帧中所有的DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率；2. 对于隐藏元素不会进行重绘或回流，减少了CPU、GPU和内存使用量；3. 由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用；页面如果不是激活状态，动画会暂停播放，有效节省了CPU开销 十二、高频度触发事件的优化方案 方案 说明 应用场景 防抖debounce 抖动结束的时间超过指定时间间隔时才执行任务 搜索联想、窗口resize 节流throttle 指定时间间隔内只执行一次任务 滚动事件、鼠标不断点击触发 十三、JS类有哪几种继承方式？各有什么特点？ 原型链继承：将父类实例作为子类原型特点：基于原型链，既是父类的实例，又是子类的实例缺点：无法实现多继承，无法向父类构造参数传参 构造继承：使用父类的构造函数来增强子类实例特点：可以实现多继承缺点：只能继承父类的实例属性和方法，不能继承原型上的属性和方法 实例继承：为父类实例添加新特性，作为子类实例返回特点：不限制调用方法缺点：实例是父类的实例，不是子类的实例，不支持多继承 拷贝继承：拷贝父类元素上的属性和方法特点：支持多继承缺点：效率低、内存占用高 组合继承：构造继承+原型链继承特点：可以继承实例属性和方法，也可以继承原型属性和方法缺点：调用两次父类构造函数，会生成两份实例 寄生组合继承：通过寄生方式，砍掉组合继承中父类的实例属性特点：避免组合继承中初始化两次实例方法和属性 参考：说一下类的创建和继承 JS原型链与继承别再被问倒了 十四、js的new操作符做了哪些事情 创建一个类的实例：创建一个空对象obj，将obj.proto设置为构造函数的prototype 初始化实例：构造函数被传入参数并调用，this指针被设定为指向该实例obj 返回实例obj 十五、改变函数内部this指针可以使用哪些函数？有什么区别？ call()：第一个参数为要改变指向的对象，之后的参数为arg1，arg2…，函数立即执行 apply()：第一个参数为要改变指向的对象，之后的参数为一个数组arguments，函数立即执行 bind()：返回一个新的函数，函数不会立即执行 call和apply作用：改变this的指向；借用别的对象的方法；调用函数 十六、如何解决js加载过程阻塞问题？ 将script标签放到body底部：此时DOM已加载完毕因此不存在阻塞问题（并非异步策略） 异步加载外部js文件：defer、async defer属性：给script标签设置defer属性，将脚本文件设置为延迟加载，遇到带有defer属性的script标签时，浏览器会再开启一个线程去下载js文件，同时继续解析HTML文档，等HTML全部解析完毕DOM加载完成后，再去执行加载好的js文件，可以保证多个js文件的执行顺序就是它们在页面中的出现顺序async属性：类似于defer属性，但与defer不同的是，它会在下载完毕后立刻执行。对于多个带有async的js文件，不保证按顺序执行，哪个js文件先下载完就先执行哪个 十七、什么是闭包？闭包有什么用？ 闭包：能够访问其他函数作用域中的变量的函数 应用：模仿块级作用域；保存外部函数的变量；封装私有变量（单例模式） 闭包与堆内存：闭包中的变量并不保存在栈内存中，而是保存在堆内存中，所以函数调用之后闭包还能引用到函数内的变量 十八、什么是立即执行函数（IIFE）？有何特点？有什么用处？ (function(){//执行语句})(); 特点：立即执行函数中的代码，又不会在内存中留下对该函数的引用；函数内部的所有变量都会被立即销毁（除非这些变量赋值给了包含作用域中的变量）作用：实现块级作用域 十九、如何理解前端模块化 模块化思想：隔离不同的js文件，仅暴露当前模块所需要的其他模块 将复杂的文件编成一个个独立的模块，有利于复用和维护。但会产生模块之间相互依赖的问题，可通过js打包工具webpack解决 二十、ES6模块化 ES6模块中自动采用严格模式，规定： 变量必须先声明 函数参数不能有同名属性 禁止this指向全局 对只读属性赋值、删除不可删除属性直接报错 arguments不可重新赋值，不会自动反应函数参数变化 增加保留字static、interface、producted等 export export语句输出的接口是对应值的引用，也就是一种动态绑定关系，通过该接口可以获取模块内部实时的值；export命令要处于模块顶层 把export直接加到声明前面 export {a, b, c} export default默认导出（一个js文件中只能有一个默认导出，但可以导出多个方法） import import是静态执行，Singleton模式；import命令要处于模块顶层 import {XX} from ‘./test.js’ import {XX as YY} from ‘./test.js’ import * as YY from ‘./test.js’ 二十一、webpack用来干什么的 js应用程序的静态模块打包器。当用webpack处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle 二十二、JS垃圾回收的两种方法 标记清除：总体思想是将寻找不再使用的对象变为寻找无法到达的对象，即从根部（全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象都是还需要使用的。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记 从根部出发将能触及到的对象的标记清除 还存在标记的变量被视为准备删除的变量 垃圾收集器执行最后一步内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间 引用计数：统计引用类型变量声明后被引用次数，当次数为0时该变量被回收。 二十三、什么是内存泄露？常见的内存泄露有哪些？如何避免？ 定义：由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费 案例： 由于未声明而意外产生的全局变量 没有回收的定时器和回调函数 闭包（闭包之间是共享作用域的） DOM元素的引用 解决方案： 减少不必要的全局变量，使用严格模式避免意外创建全局变量 使用完数据后及时解除引用（DOM引用、闭包中的变量、定时器清除） 组织好函数逻辑，避免死循环等造成浏览器卡顿和崩溃 参考：「前端进阶」JS中的内存管理 二十四、js内存空间 栈：存放变量 堆：存放复杂对象 池（一般也归类为栈中）：存放常量 栈内存由于自身数据结构的特点，系统效率较高；堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈 二十五、js基本数据类型有哪些？引用数据类型有哪些？基本数据类型和引用数据类型的区别？ 基本数据类型：null、undefined、symbol、boolean、string、number 引用数据类型：Object、Array、RegExp、Date、Function、特殊的基本包装类型（String、Number、Boolean）、单体内置对象（Global、Math） 区别： 基本数据类型的比较是值的比较；引用数据类型比较的是内存地址是否相同 基本数据类型存放在栈区；引用数据类型同时存放在栈区和堆区 基本数据类型的赋值是简单赋值；引用数据类型赋值是对象引用 基本数据类型不能添加引用和方法；引用数据类型可以 二十六、变量类型与内存的关系 基本数据类型存放在栈区（栈内存中的变量一般在其当前执行环境结束就会被销毁和回收） 基本数据类型占用空间小、大小固定，按值访问，属于被频繁使用的数据。 引用数据类型存放在栈区和堆区（堆内存中的变量只有在所有对它的引用都结束时才会被回收） 引用数据类型占用空间大、大小不固定，若存储在栈中会影响程序运行的性能；但引用数据类型的指针存储在栈中，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会先检索其在栈中的地址，取得地址后再从堆中获得实体。 二十七、跨域原理？js实现跨域 跨域：浏览器不能执行其他网站的脚本，是由浏览器的同源策略造成的，是浏览器对JS实施的安全限制（只要协议、域名、端口有任何一个不同，都被当作是不同的域） 跨域原理：通过各种方式避开浏览器的安全限制 实现方法：CORS；代理服务器；JSONP；document.domain+iframe；location.hash+iframe；window.name+iframe；postMessage 二十八、什么是symbol ES6新增属性，Symbol(description)函数生成一个全局唯一的值，能够作为对象属性的标识符；description为字符串类型，仅作为对symbol的描述，相当于一个注释。 二十九、this的指向有哪几种 默认绑定：全局环境中this默认绑定到window 隐式绑定：被直接对象所包含的函数调用时，即方法调用时，this隐式绑定到该对象上 隐式丢失：被隐式绑定的函数丢失绑定对象时，会默认绑定到window 显示绑定：通过call()、apply()、bind()方法把对象绑定到this上 new绑定：函数或方法调用前带有关键字new，就构成构造函数调用，对于this绑定来说，称为new绑定 三十、ES6箭头函数与普通函数的区别 箭头函数没有this，需要通过查找作用域链来确定this的值，即如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this 箭头函数没有自己的arguments对象，但是可以访问外围函数的arguments对象 不能通过new关键字调用，无原型 三十一、js原型链，原型链的顶端是什么？Object的原型是什么？Object的原型的原型是什么？ 注：蓝色部分为原型链 三十二、为什么js是单线程？ JavaScript作为浏览器脚本语言，主要用途是与用户互动，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题。比如若js同时拥有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除这个节点，那浏览器将不知所措。为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JS脚本创建多个线程，但子线程完全受主线程控制，且不得操作DOM，所以该标准并没有改变JS单线程的本质。 三十三、什么是Web Worker？使用Web Worker有什么注意点？ Web Worker的作用是为JS创建多线程环境，允许主线程创建Worker线程，将一些任务分配给线程运行。主线程运行的同时，Worker线程在后台运行，两者互不干扰；Worker线程完成计算任务后，再把结果返回给主线程。 注意点： 同源限制：分配给worker线程运行的脚本文件必须和主线程的脚本文件同源 DOM限制：worker线程无法读取主线程所在网页的DOM对象，无法使用document、window对象，但可以使用navigator、location对象 通信限制：worker线程和主线程不在同一上下文环境，不能直接通信，须通过消息完成 文件限制：worker线程无法读取本地文件，所加载的脚本必须来自网络 三十四、什么是事件委托/事件代理？典型例子？ 定义：不在事件发生的直接DOM上设置监听函数，而在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型（使用target属性），来做出不同的响应。 好处：新增子对象时无需再次对其绑定事件，适合动态添加元素；减少事件注册，减少内存消耗。 举例：ul和li标签的事件监听（不在li标签上直接添加事件监听而是在ul标签上添加） 三十五、什么是事件监听 element.addEventListener(event, function, useCapture) 用于向指定元素添加事件 event：事件类型，如click、scroll、mousedown、resize等 function：事件触发后调用的函数 useCapture：描述事件传递方式，可选。默认为false即冒泡传递；true时为捕获传递 三十六、什么是promise？ Promise是一个构造函数，用来生成promise实例 构造函数接收一个参数，这个参数是一个函数，当创建实例的时候，该作为参数的函数里的内容会立即执行 参数里面的函数又接收两个参数，两个参数均为函数，一个为resolve，一个为reject 异步操作成功时调用resolve，resolve函数将promise对象的状态从pending变为resolved并将结果作为参数传出去 异步操作失败时调用reject，reject函数将promise对象的状态从pending变为rejected，并将操作报出的错误作为结果传递出去 实例生成后，可以用then方法分别指定resolved状态和rejected状态的回调函数 then方法接收两个函数作为参数，分别为resolved和rejected的回调函数，第二个参数可选 catch方法在then方法后调用，发生错误时调用，本质上等同于then(null, rejected); Promise特点： 三种状态：pending、resolved（fulfilled）、rejected 对象的状态不受外部影响，只有异步操作的结果才能决定当前是哪一种状 一旦状态改变就凝固了，不会再改变（pending→resolved；pending→rejected） 参考：ES6基础之详解Promise基本用法 三十七、async和await如何使用？ async关键字用于声明一个function是异步的，被async修饰的函数返回的是一个promise；await只能在async函数中使用，用于等待一个异步方法执行完成，await等待的内容可以是常量、变量、promise、函数等。 async/await中的错误处理：使用try-catch来错误捕捉；使用promise的catch来错误捕捉 参考：理解async/await 三十八、说一下JS的事件模型 事件模型 DOM0事件模型/原始事件模型：事件不会传播，仅作为元素的一个属性 直接在HTML中绑定： 通过js代码指定属性值： var btn = document.getElementById('.btn'); btn.onclick = fun; 移除监听函数： btn.onclick=null; IE事件模型：事件处理阶段→事件冒泡阶段（目标元素→document） 绑定：attachEvent(eventType, handler) 移除：detachEvent(eventType, handler) DOM2事件模型：事件捕获阶段→事件处理阶段→事件冒泡阶段（document→目标元素→document） 绑定：addEventListener(eventType, handler, useCapture) 移除：removeEventListener(eventType, handler, useCapture) 事件对象 DOM事件模型中的事件对象常用属性 type获取事件类型 target获取事件的目标节点 stopPropagation()阻止捕获和冒泡阶段中当前事件的进一步传播 preventDefault()阻止事件默认行为而不停止事件的进一步传播 IE事件模型中的事件对象常用属性 type获取事件类型 srcElement获取事件目标 cancelBubble阻止事件冒泡 returnValue阻止事件默认行为 执行顺序 如果一个DOM节点同时绑定了多个事件监听函数，且有的用于捕获，有的用于冒泡，则绑定在被点击元素上的事件是按照代码添加顺序执行的，其他先捕获再冒泡。 三十九、浏览器中的Event Loop事件循环 JavaScript：单线程（代码执行时只有一个主线程来处理所有任务）非阻塞（当代码需要进行一项异步任务时，主线程挂起该任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调→Event Loop） 任务队列 Macrotask（宏任务）：script（整体代码）、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel Microtask（微任务）：Promise.then、Object.observe 事件循环执行流程 一次事件循环只执行位于Macrotask队首的任务，执行完成后立即执行Microtask队列中的所有任务（一开始在js主线程中跑的任务就是Macrotask任务，因此执行完主线程的代码后，会从Microtask队列中取任务来执行） 定时器问题：setTimeout不保证可靠定时 定时器中设置的时间仅保证任务会在delay毫秒后进入Macrotask队列，并不意味着它能立刻运行，因为可能当前主线程正在进行一个耗时的操作，也可能目前Microtask队列中有很多个任务。 Js是阻塞还是非阻塞的？ 核心是同步阻塞，而对于js异步事件，因为有事件循环机制，所以异步事件就是由事件驱动异步非阻塞的 requestAnimationFrame既不属于Microtask也不属于Macrotask 同步任务→promise等微任务→制作render树→requestAnimationFrame→制作render树→第一帧重绘完成→setTimeout等宏任务 四十、Node中的Event Loop事件循环 Node简介 Node.js采用V8作为js的解析引擎，而I/O处理方面使用libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制由它实现 Node.js运行机制 V8引擎解析JavaScript脚本 解析后的代码调用Node API libuv库负责Node API的执行，它将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的执行结果返回给V8引擎 V8引擎将结果返回用户 事件循环六个阶段 libuv中的事件循环分六个阶段，它们会按照顺序反复运行，每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量达到系统设定的阈值，就会进入下一阶段。 timers阶段执行setTimeout()、setInterval()的回调，由poll阶段控制（与浏览器不同，timers阶段有几个setTimeout、setInterval都会依次执行） I/O callbacks阶段：处理上一轮循环中少数未执行的I/O回调 idle，prepare阶段：仅node内部使用 poll阶段获取新的I/O事件，适当的条件下node将阻塞在这里。该阶段系统会做两件事：回到timer阶段执行回调；执行I/O回调。在进入该阶段时： 如果没有设定timer，则：1.若poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制；2.若poll队列为空，则（1）若有setImmediate回调需要执行，poll阶段会停止并且进入到check阶段执行回调；（2）若没有setImmediate回调需要执行，会等待回调被加入到队列中并立即执行回调，同时会有个超时时间防止死等。 如果设定了timer且poll队列为空，则会判断是否有timer超时，如果有的话会回到timer阶段执行回调 check阶段：执行setImmediate()的回调 close callbacks阶段：执行socket的close事件回调 MicroTask与MacroTask MacroTask：setTimeout、setInterval、setImmediate、script（整体代码）、I/O操作MicroTask：process.nextTick、Promise().then 注意点 setTimeout和setImmediate两者调用时机不同，setImmediate设计在poll阶段完成时执行，即check阶段；setTimeout设计在poll阶段为空闲时，且设定时间达到后在timer阶段执行。二者在异步I/O callbacks内部调用时，总是先执行setImmediate再执行setTimeout；其他情况先后顺序不一定（setTimeout(func, 0)===setTimeout(func, 1)，如果在准备时候花费时间大于1ms，则在timers阶段就会直接执行setTimeout回调，小于1ms先执行setImmediate回调） process.nextTick独立于Event Loop之外，有一个自己的队列，当每个阶段完成后如果存在nextTick队列，就会转而清空nextTick队列中的所有回调函数，且优先于其他microtask执行 四十一、Node与浏览器的Event Loop差异 Microtask任务队列的执行时机不同 Node端：microtask在事件循环的各个阶段之间执行 浏览器端：microtask在事件循环的macrotask执行完之后执行 参考： 面试一定会问到的-js事件循环 浏览器与Node的事件循环(Event Loop)有何区别? 【js事件循环】+ requestAnimationFrame与页面绘制在事件循环中的顺序关系 四十二、说说C++，Java，JavaScript这三种语言的区别 静态类型/动态类型 C++、Java属于静态类型语言，编译的时候就能够知道每个变量的类型，编程时需给定类型；js属于动态类型语言，运行的时候才知道每个变量的类型，编程的时候无需显示指定的类型 编译型/解释型 C++是编译型语言，需要编译器编译成本地可执行程序后才能运行，用户只使用编译好的本地代码；js是解释型语言，用户直接使用脚本解释器将脚本文件解释执行；Java分为两个阶段，首先像C++一样经过编译器编译，但生成字节码（与平台无关），然后由Java虚拟机运行字节码，使用解释器执行这些代码 js和Java的区别： Java编译字节码阶段和执行阶段是分开的，即编译阶段时间长短无所谓；对于js这些都是在网页和js文件下载后同执行阶段一起在网页的加载和渲染过程中实施的，所以对处理时间有严格要求 powered by Gitbook最后修订时间： 2020-05-26 18:06:52 "},"Chapter7/":{"url":"Chapter7/","title":"Vue","keywords":"","body":"Vue 我本人其实并没有Vue的使用经历……面试官问我的时候我就说没用过，他们就也不会追问了，就说那我们还是问一些原生JS的内容吧。 不过diff算法倒是被问到了，当时我正在说重排重绘中批量修改dom的内容，然后面试官突然打断我问怎么比较新旧节点的不同？让我说一说diff算法。 virtual dom也有被问到，Vue、React中都有virtual dom的概念，它的核心思想在前端中有很多应用，虽然有些不妥，还是把它强行归入Vue这一章节了。 powered by Gitbook最后修订时间： 2020-05-26 13:08:22 "},"Chapter7/vue生命周期.html":{"url":"Chapter7/vue生命周期.html","title":"Vue的生命周期","keywords":"","body":"Vue的生命周期 Vue实例从创建到销毁的过程就是生命周期 开始创建→初始化数据→编译模板→挂载DOM-渲染→更新-渲染→卸载 作用：vue所有的功能实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能。生命周期中有多个事件钩子，在控制整个vue实例的过程时更容易形成好的逻辑。 生命周期分为8个阶段：创建前/后、载入前/后、更新前/后、销毁前/后 钩子函数 状态 用处 beforeCreate 此阶段为实例初始化之后，this指向创建的实例，此时数据观察事件机制都未形成，不能获得DOM节点 初始化非响应式变量 created 此阶段实例创建完成，属性已绑定，数据对象data已存在，但DOM未生成，$el未存在 初始化完成事件、异步请求 beforeMount vue实例的$el和data都已初始化，此时为虚拟的DOM节点，data.message未替换 - mounted vue实例挂载完成，data.message成功渲染 发起后端请求、对挂载的DOM进行操作 beforeUpdate 数据驱动DOM 访问现有DOM updated 完成虚拟DOM的重新渲染和打补丁 对数据统一处理的函数 beforeDestory 组件销毁之前调用 销毁定时器、解绑全局事件、销毁插件对象删除提示 destroyed 组件销毁之后调用，对data的改变不会再触发周期函数，vue实例已解除事件监听和DOM绑定，但DOM结构依然存在 - 第一次页面加载时触发：beforeCreate、created、beforeMount、mounted powered by Gitbook最后修订时间： 2020-05-24 11:28:50 "},"Chapter7/双向绑定.html":{"url":"Chapter7/双向绑定.html","title":"双向绑定","keywords":"","body":"双向绑定 一、双向绑定(MVVM)原理 原理：数据变化更新视图，视图变化更新数据 Vue采用数据劫持+发布者-订阅者模式，通过Object.defineProperty()来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调（Object.defineProperty可以控制一个对象属性的一些特有操作，比如读写权、是否可以枚举等，双向绑定时主要用到set和get属性） 二、如何自己实现数据的双向绑定？ 实现一个监听器Obsrver，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者 实现一个订阅器Dep，用来收集订阅者，对监听器Observer和订阅者Watcher进行统一管理 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的方法，从而更新视图 实现一个解析器Compile，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化 powered by Gitbook最后修订时间： 2020-05-24 11:48:39 "},"Chapter7/virtual dom.html":{"url":"Chapter7/virtual dom.html","title":"virtual dom","keywords":"","body":"virtual dom 一、什么是virtual dom 用js对象结构表示DOM树结构，然后用这个树构建一个真正的DOM树，插到文档中，当状态变更时，重新构造一颗新的对象树，然后将新的树和旧的树进行比较，记录差异，并把差异以打补丁的方式应用到真正的DOM树上来更新视图。本质是JS和DOM之间做了一个缓存。 用Javascript对象表示元素，对象中有三个属性： tagName：元素的标签名 props：该元素所包含的属性 children：该元素的孩子 二、virtual dom中的diff算法 核心：逐层比较→前端中很少跨层移动dom元素→时间复杂度O(n) 多个组件拥有同一个父组件，归为一个组，整组与变化后的情况做对比，缺了就补上，多了就删除（如果发现某一个节点发生变化，则不再遍历其子节点，直接统一删除整个节点及其子节点，把新节点直接替换上去） 算法 DFS记录差异 对新旧两棵树进行深度优先遍历，这样每个节点就会有一个唯一的标记；每遍历到一个节点就把该节点和新的树进行对比，如果有差异的话就记录到一个对象里面。 差异类型 替换原来的结点：新旧节点tagName是否相同，不一样则需要替换 移动、删除、新增子节点：列表对比算法 修改节点属性/文本节点文本内容的改变：patch记录变化 对于子节点重排变化（移动）：列表对比算法 给子节点加上唯一标识key（tagName可能重复，不能用其进行对比），形成一个子节点列表。问题转化为已知新旧节点的顺序，求最小的插入、删除操作（Levenshtein Distance最小编辑距离） 三、Levenshtein Distance最小编辑距离 描述：编辑距离是指两个字串之间，由一个转成另一个所需的编辑操作次数。最小编辑距离，是指所需最小的编辑操作次数。最小编辑距离通常作为一种相似度计算函数被用于多种实际应用中。 思路：动态规划，使用dp[][]二维数组记录每次计算的值。 编辑操作包括插入、删除和替换三种操作 编辑操作 矩阵方向 删除 向右走 插入 向下走 替换/匹配 向右下走 举个例子： 假设str1=ABCD; str2=ACD 建立dp[str1.length+1][str2.length+1]dp[str1.length+1][str2.length+1]dp[str1.length+1][str2.length+1]，#表示串前可以插入任何字符 初始化矩阵 遍历矩阵并计算 dp[i][j]={dp[i][j−1]+1(1)dp[i−1][j]+1(2)dp[i−1][j−1]+1:0(3) dp[i][j]=\\begin{cases} dp[i][j-1]+1 \\quad\\quad\\quad\\quad\\quad(1)\\\\ dp[i-1][j]+1 \\quad\\quad\\quad\\quad\\quad(2)\\\\ dp[i-1][j-1]+1:0 \\quad\\quad(3)\\end{cases} dp[i][j]=​⎩​⎪​⎨​⎪​⎧​​​dp[i][j−1]+1(1)​dp[i−1][j]+1(2)​dp[i−1][j−1]+1:0(3)​​ （1）算法思想转化为：去掉str2末尾一个字符，变成str1的最小编辑距离+1 （2）算法思想转化为：去掉str1末尾一个字符，变成str2的最小编辑距离+1 （3）算法思想转化为：去掉str1和str2末尾各一个字符，若两个末尾字符相同+0，不同+1 str1和str2的最小编辑距离为dp[str1.length][str2.length]dp[str1.length][str2.length]dp[str1.length][str2.length] 参考：深入理解react中的虚拟DOM、diff算法 powered by Gitbook最后修订时间： 2020-05-26 19:01:28 "},"Chapter8/":{"url":"Chapter8/","title":"来编个程吧","keywords":"","body":"来编个程吧 有些公司没有统一笔试环节，会直接进入面试，一般跟你约好时间后上来就是一道算法题。这种算法题其实就是和笔试环节中的编程题一样的：有结合实际的题目描述，需要考虑输入输出，需要通过所有测试cases。我把这种类型算法题叫做应用题，其实就是把笔试环节和面试放一起了，直接截一道笔试里的题目来考你。给你半小时来做一道题，写不出来直接over，不会进入自我介绍、项目介绍、基础知识点考察环节。 本章的所有编程题并不是上面那种类型，而是面试官在面你的过程中，自己手动敲在问题区的题目。往往仅需要考虑面试官敲出来的一个或几个示例，他给的示例能通过就行。输入输出的话也没有很严格的限制，直接把示例作为参数传入就行。 这种编程题相对而言是很宽松的。面试官在你敲代码的过程中会给你许多提示，你要是一时半会没思路，他也会提示你。甚至在我说我能用JAVA写吗JS的某些语法不熟悉时，面试官直接就说没事你就用JS写，语法不会的我告诉你。有时候就算你写的程序跑不起来，如果整体思路OK那也可能给你算过。 可见，后一种编程题更考验面试者的思路和算法基本功（基本上都是最最最基本的算法题，不像应用题那样尽是花里胡哨的包装和变形，想方设法不让你看出本质算法），以及总是会结合一些岗位相关的技能、知识点来命题。 本章记录的12道题目中，我在面试中遇到的有： 归并&快速排序 防抖和节流 全排列 N数之和 实现promiseAll 数组和对象的深拷贝 金钱格式化 二叉树路径总和 powered by Gitbook最后修订时间： 2020-05-25 15:24:51 "},"Chapter8/归并&快速排序.html":{"url":"Chapter8/归并&快速排序.html","title":"归并&快速排序","keywords":"","body":"归并&快速排序 //归并排序 public void mergeSort(int[] arr, int left, int right) { if(left >= right) return; int mid = left + (right - left) / 2; mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); partition(arr, left, right, mid); } public void partition(int[] arr, int left, int right, int mid) { int[] res = new int[right - left + 1]; int i = left, j = mid + 1, index = 0; while(i //快速排序 public void quickSort(int[] arr, int begin, int end) { if(begin >= end) return; int base = arr[begin]; int i = begin, j = end; while(i = base) { j--; } while(i powered by Gitbook最后修订时间： 2020-05-25 15:26:37 "},"Chapter8/二分查找.html":{"url":"Chapter8/二分查找.html","title":"二分查找","keywords":"","body":"二分查找 public int find(int[] arr, int target) { int left = 0, right = arr.length; while(left public int find(int[] arr, int target) { int left = 0, right = arr.length; while(left powered by Gitbook最后修订时间： 2020-05-26 08:16:36 "},"Chapter8/全排列.html":{"url":"Chapter8/全排列.html","title":"全排列","keywords":"","body":"全排列 常见的全排列有两种：1. 输入的是一个字符串；2. 输入的是一个数组。 输入：s = \"abc\" 输出：[\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"] 输入: [1,2,3] 输出: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 总体思路都是采用回溯算法(BackTracking) Backtracking is an algorithm for finding all solutions by exploring all potential candidates. If the solution candidate turns to be not a solution (or at least not the last one), backtracking algorithm discards it by making some changes on the previous step. 上面一段话是LeetCode上关于回溯算法的总结，感觉说到了精髓。翻译一下就是： 回溯是一种通过探索所有潜在的候选方案来寻找所有解决方案的算法。如果候选的解决方案变成不是解决方案（或者至少不是最后一个），回溯算法通过对上一步进行一些改变，将其舍弃。 该算法在回溯的时候有两种不同的处理方式，下面分别以两种不同的输入参数类型做示范。 /*输入的是一个字符串*/ class Solution { private List list = new ArrayList<>(); public String[] permutation(String s) { boolean[] visited = new boolean[s.length()]; DFS(s, visited, \"\"); return list.toArray(new String[list.size()]); } private void DFS(String s, boolean[] visited, String out) { if(out.length() == s.length()) list.add(out); else { for(int i = 0; i /*输入的是一个数组*/ class Solution { private List> res = new ArrayList<>(); public List> permute(int[] nums) { List out = new ArrayList<>(); boolean[] visited = new boolean[nums.length]; DFS(nums, visited, out); return res; } private void DFS(int[] nums, boolean[] visited, List out) { if(out.size() == nums.length) res.add(new ArrayList<>(out)); else { for(int i = 0; i LeetCode链接：https://leetcode-cn.com/problems/permutations/https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/ powered by Gitbook最后修订时间： 2020-05-25 15:51:01 "},"Chapter8/N数之和.html":{"url":"Chapter8/N数之和.html","title":"N数之和","keywords":"","body":"N数之和 描述：给定一个数组arr，从中选出n个数的和等于target 面试官问我这道题的时候我现场没有想出来，事后思考了一下，其实和全排列的本质相同，只是多了两个限制条件：选出n个数、和为target，仍然可以用回溯+剪枝来实现，记得考虑去重。 class Solution { private List> res = new ArrayList<>(); public List> calSum(int[] arr, int target, int n) { List out = new ArrayList<>(); Arrays.sort(arr); //先对数组进行排序，方便后续去重 DFS(arr, target, n, out, 0); return res; } private void DFS(int[] arr, int target, int n, List out, int cur) { /*递归出口*/ if(target n || cur > arr.length) return; /*符合条件的out加入结果集中*/ else if(target == 0 && out.size() == n) { res.add(new ArrayList<>(out)); return; } else { int pre = -1; //去重：递归进入的同一层函数，所选数字不能相同 for(int i = cur; i 后来在网上搜的时候，发现了另一种解法：利用二进制来进行标记与选择。比如数组中有4个数，要选出3个数使其和为target，相当于C43C_{4}^{3}C​4​3​​，那么二进制1011就表示从4个数中选第1,3,4个数（剩下的3种情况为0111、1101、1110），选出数组中第1,3,4个数后，判断其和是否等于target，等于的话就加入结果集中。 长度为4的数组中可以有哪几种选择情况呢？因为n一定是一个正整数，所以总共有C41+C42+C43+C44=15C_{4}^{1}+C_{4}^{2}+C_{4}^{3}+C_{4}^{4}=15C​4​1​​+C​4​2​​+C​4​3​​+C​4​4​​=15种选择方案，对应就是n=1（二进制0001）到n=4（二进制1111）的所有可能，所以遍历的范围是$1\\leq i\\leq 15$，也就是$1\\leq i 该算法涉及一些位运算操作，比如按位与&和左移 class Solution { public List> calSum(int[] arr, int n, int target) { Arrays.sort(arr); //先对数组进行排序，方便后续去重 List> res = new ArrayList<>(); int len = arr.length; int bit = 1 out = new ArrayList<>(); if(countOne(i) == n) { /*二进制选取数字的方案与数组中的数的映射*/ for(int j = 0; j 0) { num = num & (num - 1); count++; } return count; } } powered by Gitbook最后修订时间： 2020-05-26 12:00:04 "},"Chapter8/二叉树路径总和.html":{"url":"Chapter8/二叉树路径总和.html","title":"二叉树路径总和","keywords":"","body":"二叉树路径总和 描述：给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 /*递归方法*/ class Solution { private List> res = new ArrayList<>(); private List out = new ArrayList<>(); public List> pathSum(TreeNode root, int sum) { helper(root, sum); return res; } private void helper(TreeNode root, int sum) { if (root == null) return; out.add(root.val); if (root.val == sum && root.right == null && root.left == null) res.add(new ArrayList<>(out)); helper(root.left, sum - root.val); helper(root.right, sum - root.val); out.remove(out.size() - 1); } } /*非递归方法*/ class Solution { public List> pathSum(TreeNode root, int sum) { List> res = new ArrayList<>(); if (root == null) return res; List stack = new ArrayList<>(); TreeNode p = root, pre = null; int val = 0; while (p != null || !stack.isEmpty()) { if (p != null) { stack.add(p); val += p.val; p = p.left; } else { TreeNode tmp = stack.get(stack.size() - 1); if (tmp.right == null && tmp.left == null && val == sum) { List out = new ArrayList<>(); for (TreeNode node : stack) out.add(node.val); res.add(out); } if (tmp.right != null && pre != tmp.right) p = tmp.right; else { pre = tmp; val -= tmp.val; stack.remove(tmp); } } } return res; } } ps. 因为二叉树的数据结构是需要自定义的，所以实际面试时面试官并没有要求我运行，他仅让我写出代码然后叙述一下思路。 LeetCode链接：https://leetcode-cn.com/problems/path-sum-ii/ powered by Gitbook最后修订时间： 2020-05-25 15:51:09 "},"Chapter8/深拷贝.html":{"url":"Chapter8/深拷贝.html","title":"深拷贝","keywords":"","body":"深拷贝 //一般对象和数组对象的克隆 function deepClone(obj) { /*数组是对象，但是和对象又有一定区别，所以需要判断newObj是数组还是对象*/ var newObj = obj instanceof Array ? []:{}; for(let i in obj) { let tmp = typeof obj[i] == 'object' ? deepClone(obj[i]) : obj[i]; newObj[i] = tmp; } return newObj; } var arr = [1,4,5,1,0]; var _arr = deepClone(arr); arr[3] = 7; //测试是否为深拷贝 console.log(arr); //输出[ 1, 4, 5, 7, 0 ] console.log(_arr); //输出[ 1, 4, 5, 1, 0 ] //原始值或包装类的克隆（String Boolean Number） function baseClone(base) { return base.valueOf(); } //Date类型：日期类定义的valueOf()方法会返回它的一个内部表示：1970年1月1日以来的毫秒数 Date.prototype.clone = function() { return new Date(this.valueOf()); }; //正则对象RegExp RegExp.prototype.clone = function() { var pattern = this.valueOf(); var flags = ''; flags += pattern.global ? 'g' : ''; flags += pattern.ignoreCase ? 'i' : ''; flags += pattern.multiline ? 'm' : ''; return new RegExp(pattern.source, flags); }; powered by Gitbook最后修订时间： 2020-05-25 15:26:48 "},"Chapter8/闭包实现单例模式.html":{"url":"Chapter8/闭包实现单例模式.html","title":"闭包实现单例模式","keywords":"","body":"闭包实现单例模式 var SingleTon = function(){ var instance; class CreateSingleTon { constructor (name) { if(instance) return instance; this.name = name; this.getName(); return instance = this; } getName() { return this.name; } } return CreateSingleTon; }(); var a = new SingleTon('instance1'); console.log(a.getName()); //输出instance1 var b = new SingleTon('instance2'); console.log(b.getName()); //输出instance1 console.log(a === b); //输出true powered by Gitbook最后修订时间： 2020-05-25 11:48:42 "},"Chapter8/防抖和节流.html":{"url":"Chapter8/防抖和节流.html","title":"防抖和节流","keywords":"","body":"防抖和节流 //防抖函数：抖动停止后的时间超过设定的时间时执行一次函数 function debounce(func, delay) { var timeout; //返回的函数在一个抖动结束后的delay毫秒内执行func函数 return function() { var context = this, args = arguments; //保存函数调用时的上下文和参数 clearTimeout(timeout); //触发func前清除定时器 timeout = setTimeout(function() { func.apply(context, args); }, delay); //用户停止某个连续动作delay毫秒后执行func }; } //节流函数：按照设定的时间固定执行一次函数 function throttle(func, delay, mustRun) { var timeout; var starttime = new Date(); //起始的时间 return function() { var context = this, args = arguments; var curtime = new Date(); //当前时间 clearTimeout(timeout); //如果达到规定的触发时间间隔，触发func if(curtime - starttime >= mustRun) { func.apply(context, args); starttime = curtime; } //没有达到触发时间，重新设定计时器 else { timeout = setTimeout(func, delay); } } } function realFunc () { console.log('bibibi'); } window.addEventListener(\"resize\", debounce(realFunc, 500)); window.addEventListener(\"scroll\", throttle(realFunc, 1000)); powered by Gitbook最后修订时间： 2020-05-25 15:26:27 "},"Chapter8/promise相关.html":{"url":"Chapter8/promise相关.html","title":"promise相关","keywords":"","body":"promise相关 /* promise的简单实现 */ class myPromise{ constructor (process) { this.status = 'pending'; this.msg = ''; process(this.resolve.bind(this), this.reject.bind(this)); return this; } resolve (val) { this.status = 'resolved'; this.msg = val; } reject (err) { this.status = 'rejected'; this.msg = err; } then (resolve, reject) { if(this.status == 'resolved') resolve(this.msg); if(this.status == 'rejected') reject(this.msg); } } //Test var my_promise = new myPromise(function(resolve, reject) { resolve('OK'); }); my_promise.then(function(val) { console.log(`success: ${val}`); }, function(err){ console.log(`failed: ${err}`); }); //输出success: OK /*实现promiseAll的功能*/ function promiseAll(promises) { return new Promise(function(resolve, reject) { var resolvedCount = 0; //成功执行的promise个数 var promiseNum = promises.length; //数组中一共有几个promise var resolvedValues = new Array(promiseNum); //保存成功解决的promise的val for(let i = 0; i powered by Gitbook最后修订时间： 2020-05-25 12:03:34 "},"Chapter8/实现set.html":{"url":"Chapter8/实现set.html","title":"实现set","keywords":"","body":"实现set class mySet { constructor() { this.items={};//js对象不允许一个键指向两个不同的属性→保证集合里元素都是唯一的 } //判断集合中是否存在val元素 has(val) { return this.items.hasOwnProperty(val); } //向集合中添加元素 add(val) { if(!this.has(val)) { this.items[val] = val; return true; } else { return false; } } //删除集合中的指定元素 remove(val) { if(this.has(val)) { delete this.items[val]; } } //清空集合中的元素 clear() { this.items={}; } //集合的大小 size() { /*Object.keys()返回给定对象所有可枚举属性的字符串数组*/ return Object.keys(this.items).length; } //获取集合中的所有元素 values(){ let res=[]; Object.keys(this.items).forEach(item=>{ res.push(this.items[item]); }) return res; } } var set = new mySet(); set.add(3); set.add(1); set.add(7); set.add(0); console.log(set.size()); //输出4 set.remove(3); console.log(set.values()); //输出[ 0, 1, 7 ] console.log(set.has(5)); //输出false set.clear(); console.log(set.size()); //输出0 powered by Gitbook最后修订时间： 2020-05-25 12:05:24 "},"Chapter8/数组去重.html":{"url":"Chapter8/数组去重.html","title":"数组去重","keywords":"","body":"数组去重 Array.prototype.uniq = function() { if(!this.length || this.length == 0) return this; var res = []; var hasNaN = false, temp = {}; /* {}==={}为false */ for(var i = 0; i 参考：JavaScript专题之数组去重 powered by Gitbook最后修订时间： 2020-05-25 14:45:17 "},"Chapter8/金钱格式化.html":{"url":"Chapter8/金钱格式化.html","title":"金钱格式化","keywords":"","body":"金钱格式化 /* *Array.prototype.reverse() Array→String *Array.prototype.join() Array→String *String.prototype.split() String→Array *String.prototype.match() String→Array */ function transferToMoney(money) { if(money && money != null) { money = String(money); var left = money.split('.')[0], right = money.split('.')[1]; right = right ? (right.length >= 2 ? '.' + right.substr(0, 2) : '.' + right + '0') : '.00'; var tmp = left.split('').reverse().join('').match(/\\d{1,3}/g); left = tmp.join(',').split('').reverse().join(''); return (Number(money) powered by Gitbook最后修订时间： 2020-05-25 14:51:24 "},"Chapter9/":{"url":"Chapter9/","title":"你还有什么问题要问我吗","keywords":"","body":"你还有什么问题要问我吗 无论是技术面还是hr面，最后肯定会有这样一个反问环节。千万不要说没有问题，没有问题表明你对公司或未来的工作毫无兴趣，仅仅是来寻求一份薪水的。也不用太小心翼翼，不用觉得问问题很蠢，主要措辞、有礼貌，大胆提问就可以了。 根据面试官的身份，可以侧重于不同方面的问题。比如技术面的时候，你可以问： 请问面试官觉得我在这次面试中有哪些不足需要改进？ 前端技术日新月异，能否分享一下您平时自我学习以适应这种更新换代的经验？ 其实大家最想问的问题是“这次面试我能过吗？“，但肯定不能这样问，所以上面第一个问题就是一个很好的替代，可以旁敲侧击了解到面试官对你的评价和感觉；第二个问题我每次技术面必问，毕竟大牛们都很喜欢向后辈分享自己的经验！而且从他们的回答中有时候的确能有不少收获。 而面对hr，则可以多问问关于公司的问题，比如： 什么时候可以入职？ 公司的晋升机制是什么样的？ 校招实习生有转正的机会吗？ 公司福利待遇如何？ 都进入hr面了，那差不多是十拿九稳，可以开始谈谈薪资福利什么的了。大胆地询问面试官你感兴趣的问题吧！ 以及，一个通用的两方都可以问的问题： 是否能分享一下您在xx公司的工作体会？ 这是个主观性很强的问题，面试官们因为在公司中承担着不同的角色，个人的感受也会有很大不同。问这个问题不仅可以提前了解一下企业文化、工作氛围、工作环境等，也能让面试官感受到你对公司深深的兴趣和憧憬，潜意识里会觉得你是个很有上进心的人，印象加分！ powered by Gitbook最后修订时间： 2020-05-25 10:20:48 "},"Chapter10/":{"url":"Chapter10/","title":"其他非技术问题","keywords":"","body":"其他非技术问题 Q：你有什么缺点？ A：我觉得我的缺点是实践经验不足，在学校里学习的知识都是一些陈旧和基础的知识，而实际工作中用到的都是前沿的新技术，这可能会让我在初期的工作中比较吃力，加上我自己的性格有时候会比较执着，就会导致为一些技术问题加班到深夜。另外我可能缺乏一些创新性思维，总是按部就班地完成任务。这些问题我想我可以进入公司后通过磨合以最短的时间来解决。我的学习能力和适应能力很强，我相信可以短期内尽快补足技术短板，融入公司氛围、进入工作状态。 （从自己的优点说起，中间加一些小缺点，最后再把问题转到优点上来） Q：对加班的看法？ A：如果是因为项目进度需求，我会义不容辞，目前没有家庭负担，可以全身心投入工作。但同时，因为刚走出校园又缺乏工作经验的原因，可能会因为个人能力问题导致不能按时完工而加班，如果是这样的话，我会努力利用休息时间尽快提升自己的技术能力，尽快熟悉业务、提高自己工作效率，减少不必要的加班。 （并不一定非要加班，面试官只是想测试一下你是否愿意为公司奉献） Q：之后的职业规划？ （问题的背后是了解你的求职动机和对自己中长期职业发展的思考） Q：说说你对行业、技术发展趋势的看法。 （有备而来。只有深入了解才能产生独特见解。公司欢迎进入公司的人是“知己”，而不是“盲人”） Q：对薪资的要求？ A：我对工资没有硬性要求，我相信公司在处理我的薪资问题上会友善合理。目前我更注重的是找对工作机会和企业平台，所以只要条件公平，我不会计较太多。 （对薪资要求太低显然贬低自己的能力，要求太高又会显得自不量力；面试官这么问只不过为了证实这份钱是否足够引起你对该工作的兴趣） Q：什么时候能入职？ （面试官最希望听到的回答是“如果被录用的话，到职日可按公司的规定上班”） Q：如果公司录用你，你将如何开展工作？ A：我想我首先应当了解部门在整个公司中的地位，以及部门的工作目标，从而确定自身的工作努力方向。其次，还要对部门的主营业务有一个充分认知，熟悉团队的业务组成部分、业务发展方向、客户群体性质等。最后，学习项目常用的开发框架和技术，利用入职前的空档期和平日休息时间尽快补足知识技术上的短板，紧密配合其他同事的工作，尽快投入到具体的开发任务中来。 （“实打实”回答，表明自己是个稳扎稳打的人） Q：你对我们公司了解多少？ （公司招聘官网上一般都有“企业文化”、“了解我们”之类的宣传栏，面试前去看一看） Q：平时有什么兴趣爱好？ （说一些富于团队合作精神的，尽量不要说单人活动） powered by Gitbook最后修订时间： 2020-05-24 16:32:00 "}}